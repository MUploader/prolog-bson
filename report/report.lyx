#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing onehalf
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Design and Implementation of a MongoDB Driver for Prolog
\end_layout

\begin_layout Author
Sebastian Lundstr√∂m
\end_layout

\begin_layout Abstract
[Prolog is good stuff, and MongoDB ...]
\end_layout

\begin_layout Abstract
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
[XXX Is the following more suitable as abstract?]
\end_layout

\begin_layout Standard
MongoDB is a document-oriented database system with a strong focus on flexibilit
y, scalability and performance.
 Document-orientation involves leaving the row-centric concept of the relational
 database model, and introducing the much more flexible notion of a document.
 Document-orientation avoids rigid database schemas and also promotes a
 certain degree of denormalization which allows embedding documents into
 each other, leading to potentially much better performance by avoiding
 the need for expensive join operations.
\end_layout

\begin_layout Standard
Prolog, being an untyped language, agrees with the document-oriented approach
 of relaxing manifests in order to create more dynamic and flexible systems.
 Embedding terms in other terms is natural in Prolog, and embedding documents
 in other documents is natural in MongoDB.
\end_layout

\begin_layout Standard
In order to use MongoDB from a programming language, some kind of interface,
 or 
\begin_inset Quotes eld
\end_inset

driver
\begin_inset Quotes erd
\end_inset

, must sit in-between the database system and the language to facilitate
 the communication.
 
\end_layout

\begin_layout Section
Purpose
\end_layout

\begin_layout Standard
The purpose of this thesis is to discuss the design and implementation of
 a MongoDB driver for Prolog.
\end_layout

\begin_layout Section
Scope
\end_layout

\begin_layout Standard
The aim of this thesis is not to create a feature-complete production-ready
 driver, but to cover basic CRUD (Create, Read, Update, Delete) functionality
 and connection handling, laying the foundation for further development.
 More advanced MongoDB features such as replication and file storage are
 therefore not covered.
\end_layout

\begin_layout Standard
Due to the lack of proper standardization within the Prolog community, maintaini
ng portability between different Prolog implementations is difficult and
 not actively pursued.
\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Standard
This chapter briefly discusses MongoDB and Prolog.
 
\emph on
XXX where discuss why prolog needs this driver? prolog is its own database,
 but using the inbuilt database for advanced applications is probably not
 that great [ref? research this].
 using a separate database system moves the database logic from the prolog
 application = good, and promotes easy replication etc.
\end_layout

\begin_layout Subsection
MongoDB
\end_layout

\begin_layout Standard
[Ref: MongoDB: The Definitive Guide, p 4]
\end_layout

\begin_layout Standard
MongoDB is a document-oriented database management system that emphasizes
 speed, scalability and flexibility.
 This is accomplished by avoiding fixed database schemas and, by sacrificing
 joins, requiring a certain degree of denormalization by embedding documents
 into each other.
\end_layout

\begin_layout Subsubsection
Document-Orientation
\end_layout

\begin_layout Standard
[XXX References, OMG.]
\end_layout

\begin_layout Standard
MongoDB employs a document-oriented view of data.
 Instead of looking at the 
\begin_inset Quotes eld
\end_inset

row
\begin_inset Quotes erd
\end_inset

 as the primary data entity, document-orientation introduces the notion
 of a 
\begin_inset Quotes eld
\end_inset

document
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
A document in MongoDB resides in a 
\begin_inset Quotes eld
\end_inset

collection
\begin_inset Quotes erd
\end_inset

, and no predefined schema is enforced on the collection.
 Therefore, documents in a collection need not share the same structure.
 This allows for great flexibility, especially with data migrations, as
 individual documents can be modified freely without updating a schema and
 affecting all documents in a collection.
\end_layout

\begin_layout Standard
A document consists of key/value pairs, where keys are strings and values
 can be of many different types, including other documents (embedded documents).
 Allowing recursive structures in the database is a step away from the more
 traditional concepts used in relational databases, where a high degree
 of normalization is often desired.
 Relaxing the need for normalization makes it possible to create highly
 efficient systems by avoiding expensive join operations.
\end_layout

\begin_layout Subsubsection
Main Features
\end_layout

\begin_layout Paragraph
Document-Oriented
\end_layout

\begin_layout Standard
MongoDB is designed to be easy to scale, and this is easier to achieve when
 the relational model is not used.
 Document-oriented databases are more flexible and impose less restrictions
 on the layout of data, allowing for complex data structures to be stored
 within a single document.
 [XXX ref? Mongo book p 1]
\end_layout

\begin_layout Paragraph
Low Maintenance
\end_layout

\begin_layout Standard
Because there are no database schemas, and databases and collections can
 be created on-the-fly without explicit commands, MongoDB requires very
 little manual maintenance.
 The database system is designed to be very automatic.
\end_layout

\begin_layout Standard
XXX out of the way, no schemas, add/remove fields from individual documents
 easy ...
\end_layout

\begin_layout Paragraph
Scalability
\end_layout

\begin_layout Standard
The MongoDB approach to scaling focuses on 
\begin_inset Quotes eld
\end_inset

scaling out
\begin_inset Quotes erd
\end_inset

 -- the process of adding more commodity servers to a cluster instead of
 replacing existing servers with better (and more expensive) ones.
 Adding more machines when the need arises is straight-forward and the database
 system itself figures out how to best configure the machines.
\end_layout

\begin_layout Subsection
BSON
\end_layout

\begin_layout Standard
XXX Discuss what BSON is, how it relates to JSON.
\end_layout

\begin_layout Standard
At the core of MongoDB lies the BSON (Binary JSON) data format which is
 used to communicate data as well as store data on disk.
 When a driver communicates with a MongoDB instance, documents are transmitted
 over the network as a series of BSON-encoded bytes.
\end_layout

\begin_layout Standard
The reason for using a binary format such as BSON is efficiency.
\end_layout

\begin_layout Subsection
Prolog
\end_layout

\begin_layout Standard
[XXX How much Prolog do I need to describe? Just enough to understand the
 code examples later on?]
\end_layout

\begin_layout Standard
Prolog is an interpreted dynamic language with its roots in logic.
 It is also a declarative language, implying that the programmer specifies
 
\emph on
what
\emph default
 the program is supposed to solve, not 
\emph on
how
\emph default
.
\end_layout

\begin_layout Subsubsection
Type System
\end_layout

\begin_layout Standard
The type system used in Prolog is dynamic, and the fundamental data type
 is the 
\begin_inset Quotes eld
\end_inset

term
\begin_inset Quotes erd
\end_inset

, which can be any value.
 A variable can be bound to any term, but once bound, it is immutable and
 cannot be rebound.
\end_layout

\begin_layout Standard
The fundamental unit of code in Prolog is the predicate.
 A predicate consists of one or more clauses, together forming a logical
 disjunction.
 The value of any predicate is either true or false, indicating whether
 the predicate succeeded.
 Any other output must be specified as arguments that are bound to values
 by the predicate before it returns.
\end_layout

\begin_layout Section
Requirements
\end_layout

\begin_layout Standard
[Ref: http://www.mongodb.org/display/DOCS/Mongo+Driver+Requirements]
\end_layout

\begin_layout Subsection
BSON Conversion
\end_layout

\begin_layout Standard
[Ref: http://bsonspec.org/]
\end_layout

\begin_layout Standard
The data representation format used by MongoDB is a binary-encoded variation
 of JSON, called BSON (Binary JSON).
 In MongoDB, BSON is the format used to store data on disk as well as transmit
 data over the network.
\end_layout

\begin_layout Standard
The driver must be able to convert back and forth between some suitable
 Prolog structure and BSON bytes.
\end_layout

\begin_layout Subsection
Connection Management
\end_layout

\begin_layout Standard
The driver must be able to obtain a connection to a database server instance
 using a TCP socket.
 All communication with the database is performed through this socket, using
 a certain protocol.
\end_layout

\begin_layout Subsection
Document Handling
\end_layout

\begin_layout Standard
The driver must expose functionality to find, insert, update and delete
 documents in the database.
\end_layout

\begin_layout Section
Design
\end_layout

\begin_layout Standard
XXX This chapter discusses the overall design of the driver.
 [xxx this will probably be the biggest chapter, I wager]
\end_layout

\begin_layout Subsection
BSON Conversion
\end_layout

\begin_layout Standard
At the core of MongoDB lies the BSON binary data format which is used to
 communicate data as well as store data on disk.
 When communicating with a MongoDB instance, documents are transmitted over
 the network as bytes of BSON.
 The driver converts Prolog stuctures into series of BSON bytes before sending
 them to the database, and database responses are converted back to Prolog
 structures again.
\end_layout

\begin_layout Standard
A BSON document is represented in Prolog as a list of key/value pairs.
 Keys are UTF-8 encoded atoms, and values can be of several different types.
\end_layout

\begin_layout Itemize
Some parts written in C.
 Why? (Basically didn't know how to easily handle bytes-to-float in Prolog.
 And perhaps some efficiency.)
\end_layout

\begin_deeper
\begin_layout Itemize
Discuss data structures, term [key:value] maps to bytelist [4,1,7,9,3,...]
 etc.
\end_layout

\begin_layout Itemize
Design choices: text as atoms (why not list of codes, [97,98,99]?) Inspired
 slightly by JSON parser: http://www.swi-prolog.org/pldoc/doc_for?object=section%2
83,%275.1%27,swi%28%27/doc/packages/http.html%27%29%29
\end_layout

\end_deeper
\begin_layout Subsubsection
BSON Encoder
\end_layout

\begin_layout Standard
XXX
\end_layout

\begin_layout Subsubsection
BSON Decoder
\end_layout

\begin_layout Standard
XXX
\end_layout

\begin_layout Subsection
Network Communication
\end_layout

\begin_layout Itemize
How does the communication work? How simplistic is the communication administrat
ion? Sockets, connections, etc.
\end_layout

\begin_layout Itemize
new_connection/1,3
\end_layout

\begin_layout Itemize
free_connection/1
\end_layout

\begin_layout Subsection
Database Interaction
\end_layout

\begin_layout Itemize
Thoroughly discuss design of wrapper API, how lists and structures are represent
ed etc.
 What algorithms are used etc.
\end_layout

\begin_layout Subsubsection
Find Documents
\end_layout

\begin_layout Standard
XXX describe the various interfaces, how cursors work
\end_layout

\begin_layout Standard
find_one/3, find_one/4, find_all/4, find/7, find/8, kill/1, kill_batch/1,
 get_more/4, has_more/1, exhaust/2
\end_layout

\begin_layout Subsubsection
Insert Documents
\end_layout

\begin_layout Standard
insert/2, insert_batch/3
\end_layout

\begin_layout Subsubsection
Update Documents
\end_layout

\begin_layout Standard
upsert/3, update/3, update_all/3
\end_layout

\begin_layout Subsubsection
Delete Documents
\end_layout

\begin_layout Standard
delete/2, delete/3
\end_layout

\begin_layout Subsubsection
Database Commands
\end_layout

\begin_layout Standard
command/3
\end_layout

\begin_layout Subsection
Error Handling
\end_layout

\begin_layout Standard
XXX how are errors in failing queries handled, for instance?
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard

\emph on
[xxx How do I solve it? What is this chapter supposed to contain?]
\end_layout

\begin_layout Standard
XXX Discuss code organization, modules? Discuss why some parts of BSON is
 implemented in C? Discuss the test suite? Discuss dependencies and portability?
 Discuss efficiency (relevant)?
\end_layout

\begin_layout Section
Evaluation
\end_layout

\begin_layout Standard

\emph on
[xxx Did it work? Is it usable? What should have been done differently?]
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard

\emph on
[xxx Compare to existing drivers? Erlang? And something completely different?
 Will probably skip this chapter.]
\end_layout

\begin_layout Section
Conclusion/Future Work [what to call it?]
\end_layout

\begin_layout Standard

\emph on
[xxx Not sure how much this section relates to Evaluation above.
\end_layout

\begin_layout Standard

\emph on
Portability (Tested on Mac, SWI, GCC/Clang, etc.)? Efficiency? How to improve
 in the future? Critical parts (BSON) in pure C? Even write a C extension
 with more/most functionality? Don't know how portable that would be though,
 but SWI (and probably SICStus?) has a mature interface to C.
 What is missing for it to be a 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 driver?]
\end_layout

\begin_layout Section
References
\end_layout

\begin_layout Standard

\emph on
[xxx References for Prolog DCG? References for various stuff used in SWI?
 At all relevant? How much web references? Most MongoDB driver stuff is
 web.]
\end_layout

\begin_layout Subsection
Books
\end_layout

\begin_layout Standard

\emph on
[xxx currently unreferenced]
\emph default
 Chodorow, K.
 & Dirolf, M.
 (2010) 
\emph on
MongoDB: The Definitive Guide.

\emph default
 Sebastopol, United States of America: O'Reilly Media, Inc.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
[xxx currently unreferenced]
\emph default
 Bratko, I.
 (2001) 
\emph on
PROLOG Programming for Artificial Intelligence.

\emph default
 3rd ed.
 Essex, England: Pearson Education Limited.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
[xxx currently unreferenced]
\emph default
 O'Keefe, R.
 A.
 (1990) 
\emph on
The Craft of Prolog.

\emph default
 Cambridge, United States of America: The MIT Press.
\end_layout

\begin_layout Subsection
Technical Documentation
\end_layout

\begin_layout Standard

\emph on
[xxx currently unreferenced]
\emph default
 MongoDB Driver Documentation
\begin_inset Newline newline
\end_inset

http://www.mongodb.org/display/DOCS/Drivers
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
[xxx currently unreferenced]
\emph default
 BSON Specification
\begin_inset Newline newline
\end_inset

http://bsonspec.org/
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\emph on
[xxx currently unreferenced]
\emph default
 SWI-Prolog Documentation
\begin_inset Newline newline
\end_inset

http://www.swi-prolog.org/pldoc/
\end_layout

\end_body
\end_document
