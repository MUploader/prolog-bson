#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing onehalf
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Design and Implementation of a MongoDB Driver for Prolog
\end_layout

\begin_layout Author
Sebastian Lundstr√∂m
\end_layout

\begin_layout Abstract
[XXX Prolog is good stuff, and MongoDB ...]
\end_layout

\begin_layout Abstract
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
[XXX Is the following more suitable as Abstract material? If so, what should
 the introduction contain?]
\end_layout

\begin_layout Standard
MongoDB is a document-oriented database system with a strong focus on flexibilit
y, scalability and performance.
 Document-orientation involves leaving the row-centric concept of the relational
 database model, and introducing the much more flexible notion of a document.
 Document-orientation avoids rigid database schemas and also promotes a
 certain degree of denormalization which allows embedding documents into
 each other, leading to potentially much better performance by avoiding
 the need for expensive join operations.
\end_layout

\begin_layout Standard
Prolog, being an untyped language, agrees with the document-oriented approach
 of relaxing manifests in order to create more dynamic and flexible systems.
 Embedding terms in other terms is natural in Prolog, and embedding documents
 in other documents is natural in MongoDB.
\end_layout

\begin_layout Standard
In order to use MongoDB from a programming language, some kind of interface,
 or 
\begin_inset Quotes eld
\end_inset

driver
\begin_inset Quotes erd
\end_inset

, must sit in-between the database system and the language to facilitate
 the communication.
 
\end_layout

\begin_layout Subsection
Purpose
\end_layout

\begin_layout Standard
The purpose of this thesis is to discuss the design and implementation of
 a MongoDB driver for Prolog.
\end_layout

\begin_layout Subsection
Scope
\end_layout

\begin_layout Standard
The aim of this thesis is not to create a feature-complete production-ready
 driver, but to cover basic CRUD (Create, Read, Update, Delete) functionality
 and connection handling, laying the foundation for further development.
 More advanced MongoDB features such as replication and file storage are
 not covered.
\end_layout

\begin_layout Standard
Due to the lack of proper standardization within the Prolog community, maintaini
ng portability between different Prolog implementations is difficult and
 not actively pursued.
\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Standard
This chapter briefly discusses MongoDB and Prolog.
\end_layout

\begin_layout Subsection
MongoDB
\end_layout

\begin_layout Standard
MongoDB is a document-oriented database management system that emphasizes
 speed, scalability and flexibility.
 This is accomplished by avoiding fixed database schemas and, by sacrificing
 joins, requiring a certain degree of denormalization by embedding documents
 into each other.
 [XXX ref: MongoDB: The Definitive Guide, p 4]
\end_layout

\begin_layout Subsubsection
Document-Orientation
\end_layout

\begin_layout Standard
[XXX lots of references missing here right now]
\end_layout

\begin_layout Standard
MongoDB employs a document-oriented view of data.
 Instead of focusing on the 
\begin_inset Quotes eld
\end_inset

row
\begin_inset Quotes erd
\end_inset

 as the primary data entity, document-orientation introduces the notion
 of a 
\begin_inset Quotes eld
\end_inset

document
\begin_inset Quotes erd
\end_inset

.
 [xxx ref mongodb p 1]
\end_layout

\begin_layout Standard
A document in MongoDB resides in a 
\begin_inset Quotes eld
\end_inset

collection
\begin_inset Quotes erd
\end_inset

, and no predefined schema is enforced on the collection.
 Therefore, documents in a collection need not share the same structure.
 This allows for great flexibility, especially with data migrations, as
 individual documents can be modified freely without updating a schema and
 affecting all documents in a collection.
\end_layout

\begin_layout Standard
A document consists of key/value pairs, where keys are strings and values
 can be of many different types, including other documents (embedded documents).
 Allowing recursive structures in the database is a step away from the more
 traditional concepts used in relational databases, where a high degree
 of normalization is often desired.
 Relaxing the need for normalization makes it possible to create highly
 efficient systems by avoiding expensive join operations.
\end_layout

\begin_layout Subsubsection
Main Features
\end_layout

\begin_layout Paragraph
Document-Oriented
\end_layout

\begin_layout Standard
MongoDB is designed to be easy to scale, a goal which is easier to achieve
 when the relational model is not used.
 Document-oriented databases are more flexible and impose less restrictions
 on the layout of data, allowing for complex data structures to be stored
 within a single document.
 
\begin_inset CommandInset citation
LatexCommand cite
key "mongodb"

\end_inset

[XXX ref? Mongo book p 1]
\end_layout

\begin_layout Paragraph
Scalability
\end_layout

\begin_layout Standard
The MongoDB approach to scaling involves 
\begin_inset Quotes eld
\end_inset

scaling out
\begin_inset Quotes erd
\end_inset

 -- the process of adding more commodity servers to a cluster instead of
 replacing existing servers with better (and more expensive) ones.
 [xxx ref mongodb p 2] Adding more machines when the need arises is straight-for
ward and the database system itself figures out how to best configure the
 machines.
 [xxx ref mongodb p 3]
\end_layout

\begin_layout Paragraph
Low Maintenance
\end_layout

\begin_layout Standard
Because there are no database schemas, and databases and collections can
 be created on-the-fly without explicit commands, MongoDB requires very
 little manual maintenance.
 The database system is designed to be very automatic.
 [xxx ref mongodb]
\end_layout

\begin_layout Subsubsection
BSON
\end_layout

\begin_layout Standard
At the core of MongoDB lies the BSON (Binary JSON) data format which is
 used to communicate data as well as store data on disk.
 When a driver communicates with a MongoDB instance, documents are transmitted
 over the network as a series of BSON encoded bytes.
\end_layout

\begin_layout Standard
BSON is similar to and heavily influenced by JSON (JavaScript Object Notation),
 the main difference being that BSON is a binary format whereas JSON is
 plain-text.
 The reason for using a binary format is efficiency.
 With JSON, numbers need to be converted to and from text in order to be
 used.
 This kind of conversion is generally slow, and BSON therefore extends the
 JSON model with a set of data types that can be parsed directly.
 For instance, a 32-bit integer is encoded in BSON as four consecutive little-en
dian bytes.
 This wastes some space for small integers, but is much faster to parse.
 [xxx ref bsonspec.org faq?]
\end_layout

\begin_layout Subsection
Prolog
\end_layout

\begin_layout Standard
[XXX How much Prolog do I need to describe? Just enough to understand the
 code examples later on?]
\end_layout

\begin_layout Standard
Prolog is an interpreted dynamic language with its roots in logic.
 It is also a declarative language, implying that the programmer specifies
 
\emph on
what
\emph default
 the program is supposed to solve, not 
\emph on
how
\emph default
.
\end_layout

\begin_layout Standard
This section gives a small introduction to Prolog in order to more easily
 appreciate the code examples in subsequent sections.
 [xxx should i say something like 
\begin_inset Quotes eld
\end_inset

for a more thorough explanation see ...
 
\begin_inset Quotes eld
\end_inset

? or is that out of scope?]
\end_layout

\begin_layout Subsubsection
Type System
\end_layout

\begin_layout Standard
The type system used in Prolog is dynamic, and the fundamental data type
 is the 
\begin_inset Quotes eld
\end_inset

term
\begin_inset Quotes erd
\end_inset

, which can be any value.
 A variable can be bound to any term, but once bound, it is immutable and
 cannot be rebound.
 Variables are recognized by an uppercase initial.
\end_layout

\begin_layout Subsubsection
Program Structure
\begin_inset CommandInset label
LatexCommand label
name "sub:Program-Structure"

\end_inset


\end_layout

\begin_layout Standard
The fundamental unit of code in Prolog is the predicate.
 A predicate consists of one or more clauses, together forming a logical
 disjunction.
 The value of any predicate is either true or false, indicating whether
 the predicate succeeded.
 Any other output must be specified as output-arguments that become bound
 by the predicate before it returns.
 The convention used for argument order is input-arguments first, intermediate
 values in the middle, and output-arguments last [xxx ref prolog guidelines].
\end_layout

\begin_layout Standard
A solution to calculate the number of elements in a list is given as follows,
 illustrating that the order of arguments is input, intermediate values,
 and finally output.
 This predicate uses an accumulator to construct the final result.
 Anonymous variables, or 
\begin_inset Quotes eld
\end_inset

don't care
\begin_inset Quotes erd
\end_inset

 variables, are denoted with an initial underscore.
 [xxx ref]
\end_layout

\begin_layout LyX-Code
length([], N, N).
\end_layout

\begin_layout LyX-Code
length([_|T], N0, N) :-
\end_layout

\begin_layout LyX-Code
    N1 is N0 + 1,
\end_layout

\begin_layout LyX-Code
    length(T, N1, N).
\end_layout

\begin_layout Standard
In an interactive Prolog environment, the above predicate may be used as
 follows, providing a starting value for the accumulator.
\end_layout

\begin_layout LyX-Code
?- length([a,b,c], 0, Length).
\end_layout

\begin_layout LyX-Code
Length = 3
\end_layout

\begin_layout Standard
A predicate is usually referred to by its name and arity (number of arguments),
 and, if possible, its module: 
\noun on
module:predicate/arity
\noun default
.
 If the 
\noun on
length
\noun default
 predicate above would be defined in the module 
\noun on
lists
\noun default
, it would be referred to as 
\noun on
lists:length/3
\noun default
.
\end_layout

\begin_layout Subsubsection
Data Structures
\end_layout

\begin_layout Standard
[XXX lots of missing refs]
\end_layout

\begin_layout Standard
The main primitive data types in Prolog are integers, floats and atoms.
 In SWI-Prolog [xxx ref SWI] integers are unbounded, and floats are represented
 as 64-bit IEEE 754 doubles.
 Atoms represent UTF-8 encoded text.
\end_layout

\begin_layout Standard
A list is an ordered collection of zero or more terms which need not be
 the same type.
 A non-empty list is a recursive structure which consists of the 
\begin_inset Quotes eld
\end_inset

head
\begin_inset Quotes erd
\end_inset

 which is the first element, and a 
\begin_inset Quotes eld
\end_inset

tail
\begin_inset Quotes erd
\end_inset

 which is itself a list of all elements except the first.
\end_layout

\begin_layout Standard
A structure is ...
 [xxx explain]
\end_layout

\begin_layout Subsubsection
Control Flow
\end_layout

\begin_layout Standard
Branching is performed by means of 
\begin_inset Quotes eld
\end_inset

backtracking
\begin_inset Quotes erd
\end_inset

 into an appropriate clause, and repetition is performed by recursion.
\end_layout

\begin_layout Standard
The first step in determining which clause to use for a certain set of input
 is accomplished through 
\begin_inset Quotes eld
\end_inset

unification
\begin_inset Quotes erd
\end_inset

, sometimes called 
\begin_inset Quotes eld
\end_inset

pattern matching
\begin_inset Quotes erd
\end_inset

.
 Prolog tries to unify the input with the formal parameters of the first
 clause of the predicate.
 If the unification fails, the process is repeated with the second clause,
 and so on.
 Invoking the predicate 
\noun on
length
\noun default
 shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Program-Structure"

\end_inset

 with a non-empty list causes unification to fail in the first clause (an
 empty list cannot be unified with a non-empty list), but succeed in the
 second (the first element is selected but ignored, and the tail is bound
 to the variable 
\noun on
T
\noun default
).
\end_layout

\begin_layout Subsubsection
Documentation Convention
\end_layout

\begin_layout Standard
When documenting Prolog predicates, each argument is usually prefixed with
 a symbol that indicates how the argument is supposed to behave.
 The following documentation convention is employed by subsequent chapters.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
+ 
\emph on
Input argument.

\emph default
 The argument must be already instantiated.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
- 
\emph on
Output argument.

\emph default
 The argument must not be already instantiated, but instead instantiated
 by the predicate.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
? The argument may or may not be instantiated.
 This is commonly used when the predicate can be used to either verify the
 argument or instantiate it.
\end_layout

\begin_layout Section
Requirements
\end_layout

\begin_layout Standard
This chapter discusses the functionality required by the driver.
\end_layout

\begin_layout Standard
[XXX main ref: http://www.mongodb.org/display/DOCS/Mongo+Driver+Requirements]
\end_layout

\begin_layout Subsection
BSON Conversion
\end_layout

\begin_layout Standard
[xxx ref: http://bsonspec.org/]
\end_layout

\begin_layout Standard
The data representation format used by MongoDB is a binary encoded variation
 of JSON, called BSON (Binary JSON).
 In MongoDB, BSON is the format used to store data on disk as well as transmit
 data over the network.
\end_layout

\begin_layout Standard
The driver must be able to convert back and forth between some suitable
 Prolog structure and BSON bytes.
\end_layout

\begin_layout Subsection
Connection Management
\end_layout

\begin_layout Standard
The driver must be able to obtain a connection to a database server instance
 using a TCP (Transmission Control Protocol) socket.
 All communication with the database is performed through this socket.
\end_layout

\begin_layout Subsection
Document Handling
\end_layout

\begin_layout Standard
The driver must expose functionality to find, insert, update and delete
 documents in a database.
\end_layout

\begin_layout Section
Design
\end_layout

\begin_layout Standard
This chapter discusses the overall design of the driver.
\end_layout

\begin_layout Subsection
Driver Organization
\end_layout

\begin_layout Standard
The driver is organized into two modules: 
\emph on
mongo
\emph default
 and 
\emph on
bson
\emph default
.
 The 
\emph on
mongo
\emph default
 module is the main module which contains all the functionality needed to
 work with a MongoDB instance.
 The 
\emph on
bson
\emph default
 module exposes functionality to handle BSON conversions between documents
 and bytes, and also document manipulation predicates.
 The 
\emph on
bson
\emph default
 module is used internally by the 
\emph on
mongo
\emph default
 module, but it is implemented separately because BSON is not inherent to
 MongoDB and can be used without it.
\end_layout

\begin_layout Subsection
BSON Handling
\end_layout

\begin_layout Standard
At the core of MongoDB lies the BSON binary data format which is used to
 communicate data as well as store data on disk.
 When communicating with a MongoDB instance, documents are transmitted over
 the network as bytes of BSON.
 The driver converts Prolog structures into series of BSON bytes before
 sending them to the database, and database responses are converted back
 to Prolog structures again.
\end_layout

\begin_layout Standard
A BSON document is represented in Prolog as a list of key/value pairs.
 A pair is a structure named '-' (dash) with two arguments, a key and a
 value.
 Using a symbol as the structure's name makes it possible to write the name
 as an infix operator, avoiding the need for parentheses.
 Keys are UTF-8 encoded atoms, and values can be of several different types.
\end_layout

\begin_layout Subsubsection
Document-to-BSON Conversion
\end_layout

\begin_layout Standard
[XXX 6.2.1 and 6.2.2 will probably be rewritten and merged into one section.
 The conversion predicate works ways and could be described as such.]
\end_layout

\begin_layout Standard
A document with two fields may look like this:
\end_layout

\begin_layout LyX-Code
[name-'MongoDB', type-db]
\end_layout

\begin_layout Subsubsection
BSON-to-Document Conversion
\end_layout

\begin_layout Standard
When converting a document to BSON, a list of bytes is obtained.
\end_layout

\begin_layout Standard
When converting between structured documents and BSON encoded bytes, the
 relation 
\noun on
bson:doc_bytes/2
\noun default
 can be used.
 This is a two-way relation that accepts a document and returns bytes, or
 accepts bytes and returns a document.
 xxxxxxxxxxxxxx
\end_layout

\begin_layout Standard
Given a list of BSON encoded bytes, the relation 
\noun on
bson:doc_bytes/2
\noun default
 can be used to convert it into its structured equivalent.
 The empty document is represented in BSON as five bytes, the first four
 being a 32-bit little-endian integer representing the length of the entire
 document, and the last byte signaling the end of the document with a zero.
\end_layout

\begin_layout LyX-Code
?- bson:doc_bytes(Doc, [12,0,0,0,16,97,0,42,0,0,0,0]).
\end_layout

\begin_layout LyX-Code
Doc = [a-42]
\end_layout

\begin_layout Standard
If a series of BSON bytes represents a concatenation of documents, the relation
 
\noun on
bson:docs_bytes/2
\noun default
 can be used.
 The following yields an empty and a non-empty document wrapped in a list.
\end_layout

\begin_layout LyX-Code
?- bson:docs_bytes(
\end_layout

\begin_layout LyX-Code
       Docs,
\end_layout

\begin_layout LyX-Code
       [5,0,0,0,0,12,0,0,0,16,97,0,42,0,0,0,0]).
\end_layout

\begin_layout LyX-Code
Docs = [[],[a-42]]
\end_layout

\begin_layout Standard
An exception is thrown if the conversion fails [xxx detail the exception].
\end_layout

\begin_layout Subsubsection
Document Manipulation
\end_layout

\begin_layout Standard
[XXX This section got very manual-ish.
 Is this relevant? Should I keep it, rewrite or omit?]
\end_layout

\begin_layout Standard
To make working with documents easier, a set of simple helper predicates
 are provided.
\end_layout

\begin_layout Paragraph
bson:doc_is_valid(+Doc)
\end_layout

\begin_layout Standard
True if Doc is a valid document and can be converted into BSON encoded bytes.
\end_layout

\begin_layout Paragraph
bson:doc_empty(?Doc)
\end_layout

\begin_layout Standard
True if Doc is an empty BSON document.
 Can be used to both check for emptiness as well as obtain an empty document.
\end_layout

\begin_layout Paragraph
bson:doc_get(+Doc, +Key, ?Value)
\end_layout

\begin_layout Standard
True if Value is the value associated with Key in Doc or +null if Key cannot
 be found.
\end_layout

\begin_layout Paragraph
bson:doc_get_strict(+Doc, +Key, ?Value)
\end_layout

\begin_layout Standard
True if Value is the value associated with Key in Doc.
 Fails if Key is not found or does not match Value.
\end_layout

\begin_layout Paragraph
bson:doc_put(+Doc, +Key, +Value, ?NewDoc)
\end_layout

\begin_layout Standard
True if NewDoc is Doc with the addition or update of the association Key-Value.
\end_layout

\begin_layout Paragraph
bson:doc_delete(+Doc, +Key, ?NewDoc)
\end_layout

\begin_layout Standard
True if NewDoc is Doc with the association removed that has Key as key.
 At most one association is removed.
 No change if Key is not found.
\end_layout

\begin_layout Paragraph
bson:doc_keys(+Doc, ?Keys)
\end_layout

\begin_layout Standard
True if Keys is the keys for the associations in Doc.
\end_layout

\begin_layout Paragraph
bson:doc_values(+Doc, ?Values)
\end_layout

\begin_layout Standard
True if Values is the values for the associations in Doc.
\end_layout

\begin_layout Paragraph
bson:doc_keys_values(+Doc, ?Keys, ?Values)
\end_layout

\begin_layout Standard
True if Doc is the list of successive associations of Keys and Values.
\end_layout

\begin_layout Subsection
Network Communication
\end_layout

\begin_layout Standard
Communication with a MongoDB instance is conducted using a TCP socket.
 [xxx ref mongo wire protocol]
\end_layout

\begin_layout Subsubsection
Obtaining a Connection
\end_layout

\begin_layout Standard
A connection can be established by the predicate 
\noun on
mongo:new_connection
\noun default
/1,3.
 Two versions of the predicate are provided, one which assumes the default
 MongoDB host and port, and one which allows this to be specified.
 If an error occurs during the setup, an exception is thrown.
\end_layout

\begin_layout LyX-Code
?- mongo:new_connection(Connection).
\end_layout

\begin_layout LyX-Code
Connection = 
\emph on
[opaque connection handle]
\end_layout

\begin_layout Standard
The following will connect to a MongoDB instance running on localhost attached
 to the port 1234.
\end_layout

\begin_layout LyX-Code
?- mongo:new_connection(localhost, 1234, Connection).
\end_layout

\begin_layout LyX-Code
Connection = 
\emph on
[opaque connection handle]
\end_layout

\begin_layout Subsubsection
Releasing a Connection
\end_layout

\begin_layout Standard
When a connection is no longer needed it must be properly released back
 to the system.
 Assuming 
\emph on
Connection
\emph default
 is a connection obtained by the predicate 
\noun on
mongo:new_connection
\noun default
/1,3, the following will release any resources associated with it, rendering
 it unusable.
\end_layout

\begin_layout LyX-Code
?- mongo:free_connection(Connection).
\end_layout

\begin_layout LyX-Code

\emph on
[Connection may no longer be used]
\end_layout

\begin_layout Subsection
Working with Data
\end_layout

\begin_layout Standard
This section gives an overview of the main functionality needed to work
 with a database and its documents.
\end_layout

\begin_layout Subsubsection
Databases and Collections
\end_layout

\begin_layout Standard
A MongoDB server can contain multiple logical databases, and each database
 can contain multiple document collections.
 Once a connection to the server has been established, a handle to a logical
 database can be retrieved by the predicate 
\noun on
mongo:get_database/3
\noun default
.
 The predicate accepts a connection handle and the name of the desired database
 as an atom, and returns a handle to the database.
 The database need not exist beforehand, and will be created when it is
 first used.
\end_layout

\begin_layout Standard
The database handle can be used to execute general database commands, but
 a collection handle must be retrieved when working with documents.
 This is accomplished by the predicate 
\noun on
mongo:get_collection/3
\noun default
, which accepts a database handle and the name of the collection, and returns
 a collection handle.
 The collection need not exist beforehand, and will be created when it is
 first used.
\end_layout

\begin_layout Subsubsection
Find Documents
\end_layout

\begin_layout Standard
Querying the database for documents is accomplished through the family of
 
\emph on
find
\emph default
 predicates.
 Depending on the nature of the query, different predicates can be used
 to retrieve, for example, a single document or all documents matching the
 query.
\end_layout

\begin_layout Standard
In general, a query returns documents in batches.
 A certain number of documents are returned with the query response, but
 if there are too many documents to fit in a single response, a 
\begin_inset Quotes eld
\end_inset

cursor
\begin_inset Quotes erd
\end_inset

 is established.
 The cursor can then be used to query for further documents.
\end_layout

\begin_layout Standard
The three main predicates for finding documents are 
\emph on
mongo:find/8
\emph default
, 
\emph on
mongo:find_one/4
\emph default
 and 
\emph on
mongo:find_all/4
\emph default
.
 The most general predicate is 
\emph on
find
\emph default
 which takes many arguments and offers very fine-grained control over the
 query.
 The interface to the predicate is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-find"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Collection
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collection handle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Query
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which documents to match
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+ReturnFields
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which fields to return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Skip
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of documents to skip
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Limit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of documents to return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Options
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List of option atoms
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-Cursor
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cursor used to fetch more documents
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-Docs
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Documents returned by the query
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-find"

\end_inset

Interface to mongo:find/8.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The predicate 
\emph on
find_one
\emph default
 is intended for the common case where you only expect one matching document.
 If no matching document is found, the returned document is the atom 'nil'.
 The interface is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-find-one"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Collection
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collection handle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Query
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which document to match
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+ReturnFields
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which fields to return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-Doc
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document returned by the query
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-find-one"

\end_inset

Interface to mongo:find_one/4.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The predicate 
\emph on
find_all
\emph default
 is intended for situations where all matching documents need processing
 and it is convenient to collect them into a single (potentially large)
 list.
 The interface is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-find-all"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Collection
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collection handle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Query
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which documents to match
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+ReturnFields
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which fields to return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-Docs
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Documents returned by the query
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-find-all"

\end_inset

Interface to mongo:find_all/4.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Using Cursors
\end_layout

\begin_layout Standard
When a query matches more documents than can be returned in a single response,
 a cursor is established and returned.
 A cursor is created and maintained by the database instance, and it represents
 a pointer to a subset of the documents matched by a query [xxx ref and
 maybe rewrite].
\end_layout

\begin_layout Standard
After making a query, the predicate 
\emph on
mongo:cursor_has_more/
\emph default
1 can be called on a cursor.
 The predicate succeeds if more documents can be retrieved, and its interface
 is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-cursor-has-more"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Cursor
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cursor to investigate
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-cursor-has-more"

\end_inset

Interface to mongo:cursor_has_more/1.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If more documents need to be retrieved, the predicate 
\emph on
mongo:cursor_get_more/4
\emph default
 can be used.
 This predicate takes a cursor, returns a number of documents and also a
 new cursor handle representing the possibly modified state of the cursor.
 The interface is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-cursor-get-more"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Cursor
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cursor to investigate
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Limit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of documents to return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-Docs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Documents returned by the query
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-NewCursor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
New state of Cursor
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-cursor-get-more"

\end_inset

Interface to mongo:cursor_has_more/1.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When a cursor is no longer needed, it must be explicitly killed in order
 for the database to clean up any resources claimed by it.
 This is accomplished by the predicate 
\emph on
mongo:cursor_kill/1
\emph default
, described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-cursor-kill"

\end_inset

.
 If several cursors need to be killed, a more efficient version called 
\emph on
mongo:cursor_kill_batch/1
\emph default
 can be used to kill them in a single database call.
 This predicate is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-cursor-kill-batch"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Cursor
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cursor to kill
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-cursor-kill"

\end_inset

Interface to mongo:cursor_kill/1.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Cursors
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List of cursors to kill
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-cursor-kill-batch"

\end_inset

Interface to mongo:cursor_kill_batch/1.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Should all remaining documents matched by a query need to be retrieved in
 a single action, the predicate 
\emph on
mongo:cursor_exhaust/2
\emph default
 can be used.
 This is a convenience predicate that simply queries the cursor until all
 documents have been retrieved, and returns them as a single list.
 A cursor exhausted by this predicate need not be manually killed.
 The interface is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-cursor-exhaust"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Cursor
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cursor to exhaust (and automatically kill)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-Docs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
All remaining documents pointed to by the cursor
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-cursor-exhaust"

\end_inset

Interface to mongo:cursor_exhaust/2.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Insert Documents
\end_layout

\begin_layout Standard
Two predicates are available to insert documents into a database collection.
 The simplest one is 
\emph on
mongo:insert/2
\emph default
, which accepts a collection handle and a document to insert, as described
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-insert"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Collection
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collection handle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Doc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document to insert
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-insert"

\end_inset

Interface to mongo:insert/2.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If several documents need to be inserted, a more efficient predicate called
 
\emph on
mongo:insert_batch/3
\emph default
 may be used.
 This predicate is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-insert-batch"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Collection
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collection handle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Options
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List of option atoms
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Docs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List of documents to insert
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-insert-batch"

\end_inset

Interface to mongo:insert_batch/3.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Update Documents
\end_layout

\begin_layout Standard
[XXX upsert/3, update/3, update_all/3]
\end_layout

\begin_layout Subsubsection
Delete Documents
\end_layout

\begin_layout Standard
Deleting documents from a collection is accomplished through the predicates
 
\emph on
mongo:delete/2
\emph default
 and 
\emph on
mongo:delete/3
\emph default
.
 Both predicates accept a collection handle and a 
\begin_inset Quotes eld
\end_inset

selector
\begin_inset Quotes erd
\end_inset

 document that describes which documents to match and delete.
 All matching documents are deleted unless the option 'single_remove' is
 supplied.
 The predicate interfaces are described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-delete-2"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-delete-3"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Collection
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collection handle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Selector
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which documents to delete
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-delete-2"

\end_inset

Interface to mongo:delete/3.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Collection
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collection handle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Selector
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which documents to delete
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Options
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List of option atoms
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-delete-3"

\end_inset

Interface to mongo:delete/3.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
General Database Commands
\end_layout

\begin_layout Standard
[XXX command/3]
\end_layout

\begin_layout Subsection
Error Handling
\end_layout

\begin_layout Standard
Errors issued by a failed query is detected by the driver and an exception
 is thrown that contains the error document returned by the database.
 The error document contains a key called 
\emph on
$err
\emph default
 that maps to an atom describing the nature of the error.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
[XXX What is this chapter supposed to contain, really? Discuss code organization
, modules? Discuss the test suite? Discuss portability? Discuss efficiency
 (relevant?)?]
\end_layout

\begin_layout Subsection
Parsing Technique
\end_layout

\begin_layout Standard
Most of the code that converts to or from lists is implemented using the
 Definite Clause Grammar (DCG) syntax in Prolog.
 This grammar technique provides a convenient interface to 
\begin_inset Quotes eld
\end_inset

difference lists
\begin_inset Quotes erd
\end_inset

, which is a common approach in Prolog to avoid unnecessary (and inefficient)
 list concatenation [XXX ref].
\end_layout

\begin_layout Subsection
C Extension
\end_layout

\begin_layout Standard
A small part of the BSON handling is written in C instead of Prolog.
 This part involves conversion of integers and floats to and from bytes.
 The two reasons for this are efficiency and ease of programming.
\end_layout

\begin_layout Standard
Being able to subvert the type system in C makes it trivial to populate
 a fixed-width number with individual bytes and then interpret them as a
 whole.
 This is especially convenient when converting between bytes and floating-point.
\end_layout

\begin_layout Standard
BSON conversion is something the driver does very often, and pushing common
 operations down to a lower-level language is likely more efficient.
\end_layout

\begin_layout Subsection
Technical Environment
\end_layout

\begin_layout Description
Prolog The driver is developed and tested on SWI-Prolog 5.10.2.
\end_layout

\begin_layout Description
C
\begin_inset space ~
\end_inset

Compiler An ANSI C compiler is required to build parts of the low-level
 BSON handling.
\end_layout

\begin_layout Description
MongoDB The driver is tested on MongoDB versions 1.8.0 and 1.8.1.
\end_layout

\begin_layout Section
Evaluation
\end_layout

\begin_layout Standard

\emph on
[xxx Did it work? Is it usable? What should have been done differently?]
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard

\emph on
[xxx Compare to existing drivers? Erlang? And something completely different?
 Will probably skip this chapter.
 Doesn't feel that interesting.]
\end_layout

\begin_layout Section
Conclusion/Future Work [merge or split?]
\end_layout

\begin_layout Standard

\emph on
[xxx Not sure how much this section relates to Evaluation above.
\end_layout

\begin_layout Standard

\emph on
Portability (Tested on Mac, SWI, GCC/Clang, etc.)? Efficiency? How to improve
 in the future? Write a C extension with more/most functionality? Incorporate
 BSON C implementation? Don't know how portable that would be though, but
 SWI (and probably SICStus?) has a mature interface to C.
 What is missing for it to be a 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 driver? Discuss choice of list as BSON document.
 Maybe use some map-like structure instead.]
\end_layout

\begin_layout Standard

\emph on
[Should I include a chapter with some kind of usage example, with a longer
 code snippet that shows what modules to include and how to actually interact
 with the driver? Is that Appendix material?]
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "xxxxx"

\end_inset

[xxx how should these be ordered? alphabetical last names? publish date?
 in order of first referenced in text?]
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "mongodb"

\end_inset

Chodorow, K.
 & Dirolf, M.
 (2010) 
\emph on
MongoDB: The Definitive Guide.

\emph default
 Sebastopol, United States of America: O'Reilly Media, Inc.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "prolog"

\end_inset

Clocksin, W.
 F.
 & Mellish, C.
 S.
 (1994) 
\emph on
Programming in Prolog.

\emph default
 4th ed.
 New York, United States of America: Springer-Verlag.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "bratko"

\end_inset

[xxx unreferenced] Bratko, I.
 (2001) 
\emph on
PROLOG Programming for Artificial Intelligence.

\emph default
 3rd ed.
 Essex, England: Pearson Education Limited.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "okeefe"

\end_inset

[xxx unreferenced] O'Keefe, R.
 A.
 (1990) 
\emph on
The Craft of Prolog.

\emph default
 Cambridge, United States of America: The MIT Press.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "guidelines"

\end_inset

Some Coding Guidelines for Prolog
\begin_inset Newline newline
\end_inset

Covington, M.
 A.
 et al.
 Retrieved 2011-06-07.
 [xxx how to format web refs?]
\begin_inset Newline newline
\end_inset

http://www.ai.uga.edu/mc/plcoding.pdf
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "driver"

\end_inset

[xxx unreferenced] MongoDB Driver Documentation
\begin_inset Newline newline
\end_inset

http://www.mongodb.org/display/DOCS/Drivers
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "bson"

\end_inset

[xxx unreferenced] BSON Specification, Retrieved 2011-06-07.
\begin_inset Newline newline
\end_inset

http://bsonspec.org/
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "swi"

\end_inset

[xxx unreferenced] SWI-Prolog Documentation
\begin_inset Newline newline
\end_inset

http://www.swi-prolog.org/pldoc/
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
\start_of_appendix
XXX Complete driver API?
\end_layout

\begin_layout Section
XXX Usage manual?
\end_layout

\end_body
\end_document
