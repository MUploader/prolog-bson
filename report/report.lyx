#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing onehalf
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Design and Implementation of a MongoDB Driver for Prolog
\end_layout

\begin_layout Author
Sebastian Lundstr√∂m
\end_layout

\begin_layout Section
Diary
\end_layout

\begin_layout Itemize
March 29.
 Wrote a decoder that decodes {hello: world} and {hello: 32}.
 Learned some DCG and rewrote the parser with it.
\end_layout

\begin_layout Itemize
March 30.
 Researched how SWI interacts with C.
 Wrote a bytes8_to_double function in C and managed to integrate it with
 the rest of the system.
 Separated bson into separate files, encoder and decoder.
 Should think about researching PlUnit by now.
 Thought about and tried PlUnit.
 Works fine.
 But how to organize tests? Implemented all bit-hacking in C for the time
 being.
 Works.
 Simple.
 Fun.
 Started looking at PlDoc.
 Generating actual docs seems like a hassle, probably won't do it.
 But the important thing is unit tests, and some comments inside the source.
 Started fleshing out the report slightly, with some ideas and stubs.
\end_layout

\begin_layout Itemize
March 31.
 Restructured project folder.
 Better including of modules now, I think.
 Starting to write nice unit tests.
 Continued with the decoder a little, the complex BSON example works.
 Wrote nice TextMate snippets for test boilerplating.
 Rewrote Makefile, yet again.
 Added make test, for instance.
\end_layout

\begin_layout Itemize
April 1.
 When trying to fix proper decoding of strings I ran into issues with Unicode.
 Finally found SWI-Prolog's memory files, which can be written to and then
 read back using a different encoding.
 Five line fix.
 Implemented a variant that might be more efficient.
 Might.
 (And like five times longer, but clean though.) Cleaned up the tests.
 Implementing the rest of the decoder should be straight-forward now.
 Next week.
 It.
 Will.
 Be.
 Awesome.
\end_layout

\begin_layout Itemize
April 2 (weekend).
 Looked into the Prolog module system again and started adding prefixes
 (
\begin_inset Quotes eld
\end_inset

memory_file:
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

builtin:
\begin_inset Quotes erd
\end_inset

) to SWI predicate calls.
 
\begin_inset Quotes eld
\end_inset

builtin
\begin_inset Quotes erd
\end_inset

 isn't an actual module, but since it works anyway (it enters the module
 builtin and calls the predicate from there) I decided to use it.
 Documented predicates in bson_bits.
 Fixed a bug with bytes_to_integer/5 because it wasn't using a 32-bit integer.
 Now it uses int32_t.
 Started using maplist/2.
 Found a library(apply_macros) that claims to speed up maplist etc.
 simply by loading it.
\end_layout

\begin_layout Itemize
April 3 (weekend).
 All use_module directives now use an empty list in order to ensure that
 the module is loaded, but nothing is imported.
 This forces me to add the appropriate module prefixes to calls.
 Benchmarked the unicode converter and the old shorter code outperformed
 the new longer code with more than a factor of three.
 I guess this is due to more stuff being done by the C library and not Prolog.
 Anyway, the old code is faster and much shorter -- win-win.
 Also replaced a crappy to-codes-and-then-to-atom conversion with a straight-to-
utf8-atom library routine, which made it even faster.
 A keeper.
\end_layout

\begin_layout Itemize
April 4.
 Refactored decoder slightly.
 Added relation term_bson/2 to bson, which calls necessary subpredicate.
 Moved tests into separate files: they were getting too long, and separating
 them makes it easier to write them simultaneously.
 As long as tests and implementation are close to each other, I am okay.
 (Impl in .pl and tests in .plt next to each other.) The decoder should now
 be feature complete.
 It does minimal error checking, but it should be able to parse all element
 types.
 It might still need some cleaning though.
 Added version predicates to bson.
 Made comments more in line with PlDoc.
\end_layout

\begin_layout Itemize
April 5.
 Major decoder cleanup.
 Took a slow day.
\end_layout

\begin_layout Itemize
April 6.
 Started on the encoder.
 Unicode issues again.
 Solved it after an hour or so, using even more library predicates.
 Factored out Unicode handling to separate module, used by both encoder
 and decoder.
 Worked a lot on the encoder, including some C hacking again.
\end_layout

\begin_layout Itemize
April 7.
 Lots more encoding of elements and encoder refactoring.
 More to come!
\end_layout

\begin_layout Itemize
April 8.
 Clean up a lot of bit-hacking in Prolog.
 Made entry-predicates into true relations and made the actual conversions
 into more general list predicates.
 Changed 
\begin_inset Quotes eld
\end_inset

builtin:
\begin_inset Quotes erd
\end_inset

 prefix to 
\begin_inset Quotes eld
\end_inset

inbuilt:
\begin_inset Quotes erd
\end_inset

, which looks nicer and is more of a single word.
 Real cleanup in all the bit-hacking.
 It sure took must of the day, but things should be pretty solid and clean
 now, and the strategy is flexible but straight-forward: all integer conversions
 back-and-forth between signed big/little 32/64-bit and bytes is done in
 C.
 If those routines cannot be used, it fails if a negative integer is being
 encoded, otherwise it is treated as an unbounded unsigned, making for instance
 ObjectID simple.
 Everything goes through either the relation 
\noun on
float_bytes(Float, Bytes)
\noun default
 which is just mappings to C, or the more intricate relation 
\noun on
integer_bytes(Integer, NumBytes, Endian, Bytes)
\noun default
 which can be called like: (+,+,+,?) or (?,+,+,+).
 E.g.
 (1, 4, little, Bytes) gives Bytes = [1,0,0,0], or (Integer, 4, big, [0,0,0,1])
 gives Integer = 1.
 The first example can be read like 
\begin_inset Quotes eld
\end_inset

the integer 1 in 4 little(-endian) bytes.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Standard
From spec:
\end_layout

\begin_layout Standard
[MongoDB is a young document-oriented database system that has started to
 gain much attention recently.
 Document-orientation involves removing rigid database schemas and advanced
 transactions, in favor of flexibility.
 Document-orientation also promotes a certain degree of denormalization
 which allows embedding documents into each other, leading to potentially
 much better performance by avoiding the need for expensive join operations.
\end_layout

\begin_layout Standard
Prolog, being an untyped language, agrees with the document-oriented approach
 of relaxing manifests in order to create more dynamic and flexible systems.
 Embedding terms in other terms is natural in Prolog, and embedding documents
 in other documents is natural in MongoDB.
\end_layout

\begin_layout Standard
Many drivers exist, both official and unofficial, that enable the use of
 Mongo\SpecialChar \-
DB from various programming languages.
 At the time of writing, no such driver for Prolog seems to exist.]
\end_layout

\begin_layout Section
Method
\end_layout

\begin_layout Standard
Research other drivers, docs.
\end_layout

\begin_layout Standard
Test-driven development.
\end_layout

\begin_layout Section
Result
\end_layout

\begin_layout Itemize
BSON encoder/decoder
\end_layout

\begin_deeper
\begin_layout Itemize
Some parts written in C.
 Why? (Basically didn't know how to easily handle bytes-to-float in Prolog.)
\end_layout

\begin_layout Itemize
Discuss data structures, term [key:value] maps to bytelist [4,1,7,9,3,...]
 etc.
\end_layout

\begin_layout Itemize
Design choices: text as 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

 and symbol as atom
\end_layout

\end_deeper
\begin_layout Itemize
Network communication
\end_layout

\begin_deeper
\begin_layout Itemize
How does the communication work? Out of scope?
\end_layout

\end_deeper
\begin_layout Itemize
MongoDB API
\end_layout

\begin_deeper
\begin_layout Itemize
Thoroughly discuss design of wrapper API, how lists and structures are represent
ed etc.
\end_layout

\end_deeper
\begin_layout Section
Discussion
\end_layout

\begin_layout Itemize
Portability
\end_layout

\begin_deeper
\begin_layout Itemize
Tested on Mac, SWI, GCC, etc.
\end_layout

\end_deeper
\begin_layout Itemize
Efficiency
\end_layout

\begin_layout Itemize
Future
\end_layout

\begin_deeper
\begin_layout Itemize
BSON implementation in C? Already exists, I think.
\end_layout

\begin_layout Itemize
More advanced features
\end_layout

\end_deeper
\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
Difficulties? Did it work? Is it usable?
\end_layout

\begin_layout Section
Literature
\end_layout

\begin_layout Standard
Chodorow, K.
 & Dirolf, M.
 (2010) 
\emph on
MongoDB: The Definitive Guide.

\emph default
 Sebastopol, United States of America: O'Reilly Media, Inc.
\end_layout

\end_body
\end_document
