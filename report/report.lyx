#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing onehalf
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Design and Implementation of a MongoDB Driver for Prolog
\end_layout

\begin_layout Author
Sebastian LundstrÃ¶m
\end_layout

\begin_layout Abstract
[XXX Prolog is good stuff, and MongoDB ...]
\end_layout

\begin_layout Abstract
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
[[[XXX Make Design into API Design, very straight-forward
\end_layout

\begin_layout Standard
Insert Usage Example
\end_layout

\begin_layout Standard
Make Implementation discuss lots more on how things are implemented, like
 BSON parsing, socket communication etc.]]]
\end_layout

\begin_layout Standard
Mongo\SpecialChar \-
DB is a document-oriented database system with a strong focus on flexibilit
y, scalability and performance.
 Document-orientation involves leaving the row-centric concept of the relational
 database model, and introducing the much more flexible notion of a document.
 Document-orientation avoids rigid database schemas and also promotes a
 certain degree of denormalization which allows embedding documents into
 each other, leading to potentially much better performance by avoiding
 the need for expensive join operations.
\end_layout

\begin_layout Standard
Prolog, being an untyped language, agrees with the document-oriented approach
 of relaxing manifests in order to create more dynamic and flexible systems.
 Embedding terms in other terms is natural in Prolog, and embedding documents
 in other documents is natural in Mongo\SpecialChar \-
DB.
\end_layout

\begin_layout Standard
In order to use Mongo\SpecialChar \-
DB from a programming language, some kind of interface,
 or 
\begin_inset Quotes eld
\end_inset

driver
\begin_inset Quotes erd
\end_inset

, must sit in-between the database system and the language to facilitate
 the communication.
\end_layout

\begin_layout Subsection
Purpose
\end_layout

\begin_layout Standard
The purpose of this thesis is to discuss the design and implementation of
 a Mongo\SpecialChar \-
DB driver for Prolog.
\end_layout

\begin_layout Subsection
Scope
\end_layout

\begin_layout Standard
The aim of this thesis is not to create a feature-complete production-ready
 driver, but to cover basic CRUD (Create, Read, Update, Delete) functionality
 and connection handling, laying the foundation for further development.
 More advanced Mongo\SpecialChar \-
DB features such as replication and file storage are
 not covered.
\end_layout

\begin_layout Standard
Due to the lack of proper standardization within the Prolog community, maintaini
ng portability between different Prolog implementations is difficult and
 not actively pursued.
\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Standard
This chapter briefly discusses Mongo\SpecialChar \-
DB and Prolog.
\end_layout

\begin_layout Subsection
MongoDB
\end_layout

\begin_layout Standard
Mongo\SpecialChar \-
DB is a document-oriented database management system that emphasizes
 speed, scalability and flexibility.
 This is accomplished by avoiding fixed database schemas and, by sacrificing
 joins, requiring a certain degree of denormalization by embedding documents
 into each other.
 See Chodorow and Dirolf (2010) for a more complete discussion.
\end_layout

\begin_layout Subsubsection
Document-Orientation
\end_layout

\begin_layout Standard
Mongo\SpecialChar \-
DB employs a document-oriented view of data 
\begin_inset CommandInset citation
LatexCommand cite
key "mongo"

\end_inset

.
 Instead of focusing on the 
\begin_inset Quotes eld
\end_inset

row
\begin_inset Quotes erd
\end_inset

 as the primary data entity, document-orientation introduces the notion
 of a 
\begin_inset Quotes eld
\end_inset

document
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
A document in Mongo\SpecialChar \-
DB resides in a 
\begin_inset Quotes eld
\end_inset

collection
\begin_inset Quotes erd
\end_inset

, and no predefined schema is enforced on the collection.
 Therefore, documents in a collection need not share the same structure.
 This allows for great flexibility, especially with data migrations, as
 individual documents can be modified freely without updating a schema and
 affecting all documents in a collection 
\begin_inset CommandInset citation
LatexCommand cite
key "mongo"

\end_inset

.
\end_layout

\begin_layout Standard
A document consists of key/value pairs, where keys are strings and values
 can be of many different types, including other documents (embedded documents).
 Allowing recursive structures in the database is a step away from the more
 traditional concepts used in relational databases, where a high degree
 of normalization is often desired.
 Relaxing the need for normalization makes it possible to create highly
 efficient systems by avoiding expensive join operations 
\begin_inset CommandInset citation
LatexCommand cite
key "mongo"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Main Features
\end_layout

\begin_layout Paragraph
Document-Orientation
\end_layout

\begin_layout Standard
Mongo\SpecialChar \-
DB is designed to be easy to scale, a goal which is easier to achieve
 when the relational model is not used.
 Document-oriented databases are more flexible and impose less restrictions
 on the layout of data, allowing for complex data structures to be stored
 within a single document 
\begin_inset CommandInset citation
LatexCommand cite
key "mongo"

\end_inset

.
\end_layout

\begin_layout Paragraph
Scalability
\end_layout

\begin_layout Standard
The Mongo\SpecialChar \-
DB approach to scaling involves 
\begin_inset Quotes eld
\end_inset

scaling out
\begin_inset Quotes erd
\end_inset

 -- the process of adding more commodity servers to a cluster instead of
 replacing existing servers with better (and more expensive) ones 
\begin_inset CommandInset citation
LatexCommand cite
key "mongo"

\end_inset

.
 Adding more machines when the need arises is straight-forward and the database
 system itself figures out how to best configure the machines.
\end_layout

\begin_layout Paragraph
Low Maintenance
\end_layout

\begin_layout Standard
Because there are no database schemas, and databases and collections can
 be created on-the-fly without explicit commands, Mongo\SpecialChar \-
DB requires very
 little manual maintenance.
 The database system is designed to be very automatic 
\begin_inset CommandInset citation
LatexCommand cite
key "mongo"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Interactive Shell
\end_layout

\begin_layout Standard
Mongo\SpecialChar \-
DB includes an interactive JavaScript-based shell that can be used
 to conveniently access the database system 
\begin_inset CommandInset citation
LatexCommand cite
key "mongo"

\end_inset

.
 In JavaScript, documents are represented as objects.
 The example in listing
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "lis:inserting-and-finding"

\end_inset

 illustrates the beginning of a shell session to create a simple blog database.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},breaklines=true,numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:inserting-and-finding"

\end_inset

Inserting and finding documents.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

$ mongo
\end_layout

\begin_layout Plain Layout

MongoDB shell version: 1.8.1
\end_layout

\begin_layout Plain Layout

connecting to: test
\end_layout

\begin_layout Plain Layout

> use blog
\end_layout

\begin_layout Plain Layout

switched to db blog
\end_layout

\begin_layout Plain Layout

> db.posts.insert(
\end_layout

\begin_layout Plain Layout

    { "title" : "My first post",
\end_layout

\begin_layout Plain Layout

      "content" : "First post!" })
\end_layout

\begin_layout Plain Layout

> db.posts.insert(
\end_layout

\begin_layout Plain Layout

    { "title" : "Second post",
\end_layout

\begin_layout Plain Layout

      "content" : "Post number 2." })
\end_layout

\begin_layout Plain Layout

> db.posts.find()
\end_layout

\begin_layout Plain Layout

{ "_id" : ObjectId("4dfb6a5de8d172995e7874d7"),
\end_layout

\begin_layout Plain Layout

  "title" : "My first post",
\end_layout

\begin_layout Plain Layout

  "content" : "First post!" }
\end_layout

\begin_layout Plain Layout

{ "_id" : ObjectId("4dfcbec7e8d172995e7874d8"),
\end_layout

\begin_layout Plain Layout

  "title" : "Second post",
\end_layout

\begin_layout Plain Layout

  "content" : "Post number 2." }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Line
\begin_inset space ~
\end_inset

4 switches to the database called 
\begin_inset Quotes eld
\end_inset

blog
\begin_inset Quotes erd
\end_inset

, but does not create it.
 Lines
\begin_inset space ~
\end_inset

6 and 9 insert two documents into the collection 
\begin_inset Quotes eld
\end_inset

posts
\begin_inset Quotes erd
\end_inset

.
 The first insert is the first command to manipulate data inside the database,
 so this triggers the actual creation of both the database and the collection.
 Because no arguments are passed to the 
\begin_inset Quotes eld
\end_inset

find
\begin_inset Quotes erd
\end_inset

 call on line
\begin_inset space ~
\end_inset

12, it retrieves all documents in the collection, which are the ones we
 just inserted.
\end_layout

\begin_layout Standard
A new field called 
\begin_inset Quotes eld
\end_inset

_id
\begin_inset Quotes erd
\end_inset

 has been added to both documents.
 Unless a document already has such a field, one is automatically generated
 by the database when it is first inserted.
 This field must be able to uniquely identify documents within a collection
 
\begin_inset CommandInset citation
LatexCommand cite
key "mongo"

\end_inset

.
\end_layout

\begin_layout Standard
To add comments to the first blog post, an update can be issued, illustrated
 in listing
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "lis:adding-a-field"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:adding-a-field"

\end_inset

Adding a field to a document.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

> db.posts.update(
\end_layout

\begin_layout Plain Layout

    { "_id" : ObjectId("4dfb6a5de8d172995e7874d7") },
\end_layout

\begin_layout Plain Layout

    { "$set" : { "comments" : [ "Good post!" ] } },
\end_layout

\begin_layout Plain Layout

    false,
\end_layout

\begin_layout Plain Layout

    false)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An update expects four arguments: a document indicating which document(s)
 to update, a document describing the update to perform, and two booleans
 indicating whether to perform an 
\begin_inset Quotes eld
\end_inset

upsert
\begin_inset Quotes erd
\end_inset

 [XXX footnote?] and if multiple documents should be updated if the query
 matches more than one.
\end_layout

\begin_layout Standard
The document describing the update to perform (the second argument) includes
 a special field called 
\begin_inset Quotes eld
\end_inset

$set
\begin_inset Quotes erd
\end_inset

.
 This field is a document that contains fields to be set (in this case added)
 in the updated document.
 Displaying all documents after performing the update is illustrated in
 listing
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "lis:displaying-documents-of"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\begin_inset CommandInset label
LatexCommand label
name "lis:displaying-documents-of"

\end_inset

Displaying documents of different structure.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

> db.posts.find()
\end_layout

\begin_layout Plain Layout

{ "_id" : ObjectId("4dfcbec7e8d172995e7874d8"),
\end_layout

\begin_layout Plain Layout

  "title" : "Second post",
\end_layout

\begin_layout Plain Layout

  "content" : "Post number 2." }
\end_layout

\begin_layout Plain Layout

{ "_id" : ObjectId("4dfb6a5de8d172995e7874d7"),
\end_layout

\begin_layout Plain Layout

  "comments" : [ "Good post!" ],
\end_layout

\begin_layout Plain Layout

  "content" : "First post!",
\end_layout

\begin_layout Plain Layout

  "title" : "My first post" }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The updated document now contains an embedded array with a single comment.
 Listing
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "lis:adding-to-an-array"

\end_inset

 shows what happens if another comment is added.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout

\begin_inset CommandInset label
LatexCommand label
name "lis:adding-to-an-array"

\end_inset

Adding to an array.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

> db.posts.update(
\end_layout

\begin_layout Plain Layout

    { "_id" : ObjectId("4dfb6a5de8d172995e7874d7") },
\end_layout

\begin_layout Plain Layout

    { "$push" : { "comments" : "Interesting." } },
\end_layout

\begin_layout Plain Layout

    false,
\end_layout

\begin_layout Plain Layout

    false)
\end_layout

\begin_layout Plain Layout

> db.posts.find()
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

{ "_id" : ObjectId("4dfb6a5de8d172995e7874d7"),
\end_layout

\begin_layout Plain Layout

  "comments" : [ "Good post!", "Interesting." ],
\end_layout

\begin_layout Plain Layout

  "content" : "First post!",
\end_layout

\begin_layout Plain Layout

  "title" : "My first post" }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
BSON
\begin_inset CommandInset label
LatexCommand label
name "sub:BSON"

\end_inset


\end_layout

\begin_layout Standard
At the core of Mongo\SpecialChar \-
DB lies the BSON (Binary JSON) 
\begin_inset CommandInset citation
LatexCommand cite
key "bson"

\end_inset

 data format which is used to communicate data as well as store data on
 disk.
 When a driver communicates with a Mongo\SpecialChar \-
DB instance, documents are transmitted
 over the network as a series of BSON encoded bytes.
\end_layout

\begin_layout Standard
BSON is similar to and heavily influenced by JSON (JavaScript Object Notation)
 
\begin_inset CommandInset citation
LatexCommand cite
key "json"

\end_inset

, the main difference being that BSON is a binary format whereas JSON is
 plain-text.
 The reason for using a binary format is efficiency.
 With JSON, numbers need to be converted to and from text in order to be
 used.
 This kind of conversion is generally slow, and BSON therefore extends the
 JSON model with a set of data types that can be parsed directly.
 For instance, a 32-bit integer is encoded in BSON as four consecutive little-en
dian bytes.
 This wastes some space for small integers, but is much faster to parse
 
\begin_inset CommandInset citation
LatexCommand cite
key "bson"

\end_inset

.
\end_layout

\begin_layout Subsection
Prolog
\end_layout

\begin_layout Standard
Prolog is an interpreted and dynamic language with its roots in logic.
 It is also a declarative language, implying that the programmer specifies
 
\emph on
what
\emph default
 the program is supposed to solve, not 
\emph on
how
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "bratko"

\end_inset

.
\end_layout

\begin_layout Standard
This section gives a small introduction to Prolog in order to more easily
 appreciate the code examples in subsequent sections.
 See Clocksin and Mellish (1994) or Bratko (2001) for a more complete discussion.
\end_layout

\begin_layout Subsubsection
Type System
\end_layout

\begin_layout Standard
The type system used in Prolog is dynamic, and the fundamental data type
 is the 
\begin_inset Quotes eld
\end_inset

term
\begin_inset Quotes erd
\end_inset

, which can be any value.
 A variable can be bound to any term, but once bound, it is immutable and
 cannot be rebound 
\begin_inset CommandInset citation
LatexCommand cite
key "prolog"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Data Structures
\end_layout

\begin_layout Standard
The main primitives in Prolog are 
\emph on
integer
\emph default
s, 
\emph on
floats
\emph default
 and 
\emph on
atom
\emph default
s.
 In SWI-Prolog, integers are unbounded and floats are represented as 64-bit
 IEEE 754 doubles.
 Atoms represent UTF-8 encoded text 
\begin_inset CommandInset citation
LatexCommand cite
key "swi"

\end_inset

.
\end_layout

\begin_layout Standard
A 
\emph on
structure
\emph default
 is a compound value with a fixed number of components and possibly a name
 
\begin_inset CommandInset citation
LatexCommand cite
key "prolog"

\end_inset

.
 The components are terms that need not share the same type and can be anything,
 including variables and other structures.
 Structures are often used to represent trees.
\end_layout

\begin_layout Standard
A 
\emph on
list
\emph default
 is a sequence of zero or more terms which need not share the same type
 
\begin_inset CommandInset citation
LatexCommand cite
key "prolog"

\end_inset

.
 A non-empty list is a recursive structure that consists of a 
\begin_inset Quotes eld
\end_inset

head
\begin_inset Quotes erd
\end_inset

 which is the first element, and a 
\begin_inset Quotes eld
\end_inset

tail
\begin_inset Quotes erd
\end_inset

 which is itself a list of all elements except the first.
 If a list has only one element, its tail is the empty list.
 The empty list has neither head nor tail.
\end_layout

\begin_layout Subsubsection
Unification
\end_layout

\begin_layout Standard
XXXXXXXXXXXXX
\end_layout

\begin_layout Standard
Variables are recognized by an uppercase initial.
\end_layout

\begin_layout Standard
xxxxxxxxxxx Anonymous variables, or 
\begin_inset Quotes eld
\end_inset

don't care
\begin_inset Quotes erd
\end_inset

 variables, are denoted by an initial underscore.
 [xxx ref] Anonymous variables are used when xx struct forces xxx
\end_layout

\begin_layout Standard
XXX rewrite this: 
\end_layout

\begin_layout Standard
The first step in determining which clause to use for a certain set of input
 is accomplished through 
\begin_inset Quotes eld
\end_inset

unification
\begin_inset Quotes erd
\end_inset

, sometimes called 
\begin_inset Quotes eld
\end_inset

pattern matching
\begin_inset Quotes erd
\end_inset

.
 Prolog tries to unify the input with the formal parameters of the first
 clause of the predicate.
 If the unification fails, the process is repeated with the second clause,
 and so on.
 Invoking the predicate 
\noun on
length
\noun default
 shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Program-Structure"

\end_inset

 with a non-empty list causes unification to fail in the first clause (an
 empty list cannot be unified with a non-empty list), but succeed in the
 second (the first element is selected but ignored, and the tail is bound
 to the variable 
\noun on
T
\noun default
).
\end_layout

\begin_layout Subsubsection
Program Structure
\begin_inset CommandInset label
LatexCommand label
name "sub:Program-Structure"

\end_inset


\end_layout

\begin_layout Standard
The fundamental unit of code in Prolog is the predicate (also called relation)
 
\begin_inset CommandInset citation
LatexCommand cite
key "prolog"

\end_inset

.
 A predicate consists of one or more clauses, together forming a logical
 disjunction.
 The value of any predicate is either true or false, indicating whether
 the predicate succeeded.
 Any other output must be specified as output-arguments that become bound
 by the predicate before it returns.
 The convention used for argument order is input-arguments first, intermediate
 values in the middle, and output-arguments last 
\begin_inset CommandInset citation
LatexCommand cite
key "guidelines"

\end_inset

.
\end_layout

\begin_layout Standard
A program to calculate the number of elements in a list is given in listing
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lis:length-program"

\end_inset

.
 This predicate follows the conventional argument order and uses an 
\begin_inset Quotes eld
\end_inset

accumulator
\begin_inset Quotes erd
\end_inset

 to construct the final result.
 An accumulator is a fabricated extra argument that holds the state of something
 produced 
\begin_inset Quotes eld
\end_inset

so far
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "prolog"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Prolog,numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:length-program"

\end_inset

A program relating a list to its length, using an accumulator.
\end_layout

\end_inset

length([], N, N).
\end_layout

\begin_layout Plain Layout

length([_|T], N0, N) :-
\end_layout

\begin_layout Plain Layout

    N1 is N0 + 1,
\end_layout

\begin_layout Plain Layout

    length(T, N1, N).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The program in listing
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lis:length-program"

\end_inset

 takes three arguments: a list, an accumulator used to successively accumulate
 the length, and the length of the list.
 To calculate the length, the third argument is passed as an unbound variable.
 On the other hand, if the length is instead a value, the predicate verifies
 if the relation between the list and the given length holds, and fails
 (returns false) otherwise.
\end_layout

\begin_layout Standard
Line
\begin_inset space ~
\end_inset

1 holds the first clause, which is a base (non-recursive) case that states
 that the length of an empty list is the same as the value of the accumulator.
 This means that the initial value of the accumulator must be zero in order
 for the relation to be meaningful.
\end_layout

\begin_layout Standard
Line
\begin_inset space ~
\end_inset

2 starts the second clause, which deals with non-empty lists.
 The construct 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Prolog"
inline true
status open

\begin_layout Plain Layout

[_|T]
\end_layout

\end_inset

 states that the head of the list (first element) is bound to an anonymous
 variable and the tail of the list (all but the first element) is bound
 to the variable 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Prolog"
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

.
 The variable 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Prolog"
inline true
status open

\begin_layout Plain Layout

N1
\end_layout

\end_inset

 is bound to the value of the current accumulator plus one, using the 
\emph on
is
\emph default
-operator to perform the addition.
 The 
\begin_inset Quotes eld
\end_inset

plus
\begin_inset space ~
\end_inset

one
\begin_inset Quotes erd
\end_inset

 indicates that we have successfully counted one element, the head of the
 list.
 The predicate then continues by invoking itself recursively, passing the
 tail of the list, the updated accumulator, and the final length of the
 list.
 The final length is bound to the final value of the accumulator as soon
 as the tail of the list is empty and the base case can be matched.
\end_layout

\begin_layout Paragraph
Execution Example
\end_layout

\begin_layout Standard
In an interactive Prolog environment, the predicate in listing
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lis:length-program"

\end_inset

 may be used as follows, providing a starting value of zero for the accumulator.
 The example in listing
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lis:trace-of-length"

\end_inset

 is illustrated using a 
\begin_inset Quotes eld
\end_inset

trace
\begin_inset Quotes erd
\end_inset

, a debugging tool used extensively in Prolog to show each step taken to
 satisfy a query.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Prolog,numbers=left,numberstyle={\scriptsize},tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:trace-of-length"

\end_inset

Trace of a call to 
\emph on
length/3
\emph default
.
\end_layout

\end_inset

[trace]  ?- length([a,b,c], 0, Length).
\end_layout

\begin_layout Plain Layout

   Call: (6) length([a, b, c], 0, _G391) ? creep
\end_layout

\begin_layout Plain Layout

^  Call: (7) _G476 is 0+1 ? creep
\end_layout

\begin_layout Plain Layout

^  Exit: (7) 1 is 0+1 ? creep
\end_layout

\begin_layout Plain Layout

   Call: (7) length([b, c], 1, _G391) ? creep
\end_layout

\begin_layout Plain Layout

^  Call: (8) _G479 is 1+1 ? creep
\end_layout

\begin_layout Plain Layout

^  Exit: (8) 2 is 1+1 ? creep
\end_layout

\begin_layout Plain Layout

   Call: (8) length([c], 2, _G391) ? creep
\end_layout

\begin_layout Plain Layout

^  Call: (9) _G482 is 2+1 ? creep
\end_layout

\begin_layout Plain Layout

^  Exit: (9) 3 is 2+1 ? creep
\end_layout

\begin_layout Plain Layout

   Call: (9) length([], 3, _G391) ? creep
\end_layout

\begin_layout Plain Layout

   Exit: (9) length([], 3, 3) ? creep
\end_layout

\begin_layout Plain Layout

   Exit: (8) length([c], 2, 3) ? creep
\end_layout

\begin_layout Plain Layout

   Exit: (7) length([b, c], 1, 3) ? creep
\end_layout

\begin_layout Plain Layout

   Exit: (6) length([a, b, c], 0, 3) ? creep
\end_layout

\begin_layout Plain Layout

Length = 3.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In listing
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lis:trace-of-length"

\end_inset

, line
\begin_inset space ~
\end_inset

1 shows the query being posed, which is to find the length of a list of
 three elements.
 Line
\begin_inset space ~
\end_inset

2 shows the first call being made, which matches the second clause of the
 predicate due to the non-empty list.
 Variables are renamed internally by Prolog and can be identified by the
 
\begin_inset Quotes eld
\end_inset

_G
\begin_inset Quotes erd
\end_inset

 prefix.
 The initial accumulator of zero is incremented by one and bound to the
 variable 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Prolog"
inline true
status open

\begin_layout Plain Layout

_G476
\end_layout

\end_inset

 on line
\begin_inset space ~
\end_inset

3.
 Line
\begin_inset space ~
\end_inset

4 indicates with the word 
\begin_inset Quotes eld
\end_inset

exit
\begin_inset Quotes erd
\end_inset

 that this call succeeded.
 Line
\begin_inset space ~
\end_inset

5 makes a recursive call with the tail of the list, the incremented accumulator
 and the same unbound variable used for the final result.
 This recursive process is repeated until line
\begin_inset space ~
\end_inset

11, where the tail of the list contains no elements.
\end_layout

\begin_layout Standard
On line
\begin_inset space ~
\end_inset

11, the first clause (the base case) of the predicate matches the empty
 list and so the resulting length is bound to the value of the accumulator,
 which is 3.
 Because the base case has been reached, no more steps are needed to satisfy
 the query.
 The recursion unfolds, showing the final bindings for each successful call
 on the way back to the initial call.
 The last argument is bound to the value 3 which is the expected answer.
\end_layout

\begin_layout Subsubsection
Control Flow
\end_layout

\begin_layout Standard
Branching is performed by 
\begin_inset Quotes eld
\end_inset

backtracking
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "prolog"

\end_inset

.
 Prolog works in a top-down, depth-first fashion when evaluating predicates.
 Calling the predicate 
\emph on
length/3
\emph default
 in listing
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "lis:length-program"

\end_inset

 with a non-empty list will make Prolog first try to unify with the first
 clause.
 This fails, and the second clause is backtracked into.
 Should this clause also fail for some reason, the next clause after that
 would be tried, and so on, until no more clauses are found and the predicate
 fails.
\end_layout

\begin_layout Standard
Iteration is performed by recursion 
\begin_inset CommandInset citation
LatexCommand cite
key "prolog"

\end_inset

.
 The predicate 
\emph on
length/3
\emph default
 in listing
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "lis:length-program"

\end_inset

 is a recursive predicate because it is defined in terms of itself.
 To solve the problem of calculating the length of a list, the predicate
 solves a smaller problem, namely calculating the length of a shorter list:
 the tail.
 It works its way to the base case and eventually arrives at a solution.
\end_layout

\begin_layout Subsubsection
Documentation Convention
\end_layout

\begin_layout Standard
When documenting Prolog predicates, each argument is usually prefixed with
 a symbol that indicates how the argument is supposed to behave 
\begin_inset CommandInset citation
LatexCommand cite
key "guidelines"

\end_inset

.
 The following documentation convention is employed by subsequent chapters.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
+ 
\emph on
Input.

\emph default
 Argument must be already instantiated.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
- 
\emph on
Output.

\emph default
 Argument must not be already instantiated, but become instantiated by the
 predicate.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
? [XXX used?] Argument may or may not be instantiated.
 This is commonly used when the predicate can be used to either verify the
 argument or instantiate it.
\end_layout

\begin_layout Standard
A predicate is referred to by its name and arity (number of arguments),
 and, if applicable, its module: 
\emph on
module:predicate/arity
\emph default
.
 Should the 
\begin_inset Quotes eld
\end_inset

length
\begin_inset Quotes erd
\end_inset

 predicate in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sub:Program-Structure"

\end_inset

 be defined in the module 
\begin_inset Quotes eld
\end_inset

lists
\begin_inset Quotes erd
\end_inset

, it would be referred to as 
\emph on
lists:length/3
\emph default
.
\end_layout

\begin_layout Section
Requirements
\end_layout

\begin_layout Standard
This chapter discusses the functionality to be implemented by the driver.
\end_layout

\begin_layout Subsection
Suggested Features
\begin_inset CommandInset label
LatexCommand label
name "sub:Suggested-Features"

\end_inset


\end_layout

\begin_layout Standard
The Mongo\SpecialChar \-
DB Driver Requirements 
\begin_inset CommandInset citation
LatexCommand cite
key "driver_req"

\end_inset

 list the following items as high priority for a driver to provide, in no
 particular order:
\end_layout

\begin_layout Enumerate
BSON serialization/deserialization,
\end_layout

\begin_layout Enumerate
full cursor support,
\end_layout

\begin_layout Enumerate
close exhausted cursors,
\end_layout

\begin_layout Enumerate
support for running database commands,
\end_layout

\begin_layout Enumerate
handle query errors,
\end_layout

\begin_layout Enumerate
convert all strings to UTF-8 (part of proper support for BSON),
\end_layout

\begin_layout Enumerate
hint, explain, count, $where,
\end_layout

\begin_layout Enumerate
database profiling,
\end_layout

\begin_layout Enumerate
advanced connection management, and
\end_layout

\begin_layout Enumerate
automatic reconnection.
\end_layout

\begin_layout Subsection
Selected Features
\end_layout

\begin_layout Standard
To keep development focused on providing just enough functionality to use
 the database system as data storage and retrieval, the driver focuses on
 items 1-6 and omits items 7-10 from the list in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sub:Suggested-Features"

\end_inset

.
 The selected requirements are further described in this section.
\end_layout

\begin_layout Subsubsection
BSON Conversion
\end_layout

\begin_layout Standard
The driver must be able to convert back and forth between some idiomatic
 Prolog structure and BSON bytes.
\end_layout

\begin_layout Subsubsection
Connection Management
\end_layout

\begin_layout Standard
The driver must be able to obtain a connection to a database server using
 a TCP (Transmission Control Protocol) socket.
 All communication with the database is performed through this socket.
\end_layout

\begin_layout Subsubsection
Database Commands
\end_layout

\begin_layout Standard
The driver must be able to execute arbitrary database commands, such as
 creating and dropping collections.
\end_layout

\begin_layout Subsubsection
Document Handling
\end_layout

\begin_layout Standard
The driver must expose functionality to find, insert, update and delete
 documents in a collection, providing basic CRUD (Create, Read, Update,
 Delete) facilities.
\end_layout

\begin_layout Section
Design
\end_layout

\begin_layout Subsection
Documents in Prolog
\end_layout

\begin_layout Standard
[XXX How are BSON documents designed?]
\end_layout

\begin_layout Standard
One advantage of working in a high-level language with a rich syntax such
 as Prolog is the ability to express complex structures as literals.
\end_layout

\begin_layout Subsection
Driver API
\end_layout

\begin_layout Standard
This chapter discusses the overall design of the driver and describes its
 Application Programming Interface (API).
\end_layout

\begin_layout Subsubsection
Driver Organization
\end_layout

\begin_layout Standard
The driver is organized into two modules: 
\emph on
mongo
\emph default
 and 
\emph on
bson
\emph default
.
 The mongo module is the main module which contains all the functionality
 needed to work with a MongoDB instance.
 The bson module exposes functionality to handle BSON conversions between
 documents and bytes, and also document manipulation predicates.
 The bson module is used internally by the mongo module, but implemented
 separately because BSON is not inherent to MongoDB and can be used without
 it.
\end_layout

\begin_layout Subsubsection
BSON Handling [XXX Rewrite and merge with 4.1]
\end_layout

\begin_layout Standard
At the core of MongoDB lies the BSON binary data format which is used to
 communicate data as well as store data on disk.
 When communicating with a MongoDB instance, documents are transmitted over
 the network as bytes of BSON.
 The driver converts Prolog structures into series of BSON bytes before
 sending them to the database, and database responses are converted back
 to Prolog structures again.
\end_layout

\begin_layout Standard
A BSON document is represented in Prolog as a list of key/value pairs, also
 called fields.
 A pair is a structure named '-' (dash) with two arguments, a key and a
 value.
 Using a symbol as the name of the structure makes it possible to write
 the name as an infix operator, avoiding the need for parentheses.
 Keys are UTF-8 encoded atoms, and values can be of several different types.
\end_layout

\begin_layout Paragraph
Document-to-BSON Conversion
\end_layout

\begin_layout Standard
[XXX 6.2.1 and 6.2.2 will probably be rewritten and merged into one section.
 The conversion predicate works ways and could be described as such.]
\end_layout

\begin_layout Standard
A document with two fields may look like this:
\end_layout

\begin_layout LyX-Code
[name-'MongoDB', type-db]
\end_layout

\begin_layout Paragraph
BSON-to-Document Conversion
\end_layout

\begin_layout Standard
When converting a document to BSON, a list of bytes is obtained.
\end_layout

\begin_layout Standard
When converting between structured documents and BSON encoded bytes, the
 relation 
\noun on
bson:doc_bytes/2
\noun default
 can be used.
 This is a two-way relation that accepts a document and returns bytes, or
 accepts bytes and returns a document.
 xxxxxxxxxxxxxx
\end_layout

\begin_layout Standard
Given a list of BSON encoded bytes, the relation 
\noun on
bson:doc_bytes/2
\noun default
 can be used to convert it into its structured equivalent.
 The empty document is represented in BSON as five bytes, the first four
 being a 32-bit little-endian integer representing the length of the entire
 document, and the last byte signaling the end of the document with a zero.
\end_layout

\begin_layout LyX-Code
?- bson:doc_bytes(Doc, [12,0,0,0,16,97,0,42,0,0,0,0]).
\end_layout

\begin_layout LyX-Code
Doc = [a-42]
\end_layout

\begin_layout Standard
If a series of BSON bytes represents a concatenation of documents, the relation
 
\noun on
bson:docs_bytes/2
\noun default
 can be used.
 The following yields an empty and a non-empty document wrapped in a list.
\end_layout

\begin_layout LyX-Code
?- bson:docs_bytes(
\end_layout

\begin_layout LyX-Code
       Docs,
\end_layout

\begin_layout LyX-Code
       [5,0,0,0,0,12,0,0,0,16,97,0,42,0,0,0,0]).
\end_layout

\begin_layout LyX-Code
Docs = [[],[a-42]]
\end_layout

\begin_layout Standard
An exception is thrown if the conversion fails [xxx detail the exception].
\end_layout

\begin_layout Paragraph
Document Manipulation
\end_layout

\begin_layout Standard
[XXX This section got very manual-ish.
 Is this relevant? Should I keep it, rewrite or omit?]
\end_layout

\begin_layout Standard
To make working with documents easier, a set of simple helper predicates
 are provided.
\end_layout

\begin_layout Subparagraph
bson:doc_is_valid(+Doc)
\end_layout

\begin_layout Standard
True if Doc is a valid document and can be converted into BSON encoded bytes.
\end_layout

\begin_layout Subparagraph
bson:doc_empty(?Doc)
\end_layout

\begin_layout Standard
True if Doc is an empty BSON document.
 Can be used to both check for emptiness as well as obtain an empty document.
\end_layout

\begin_layout Subparagraph
bson:doc_get(+Doc, +Key, ?Value)
\end_layout

\begin_layout Standard
True if Value is the value associated with Key in Doc or +null if Key cannot
 be found.
\end_layout

\begin_layout Subparagraph
bson:doc_get_strict(+Doc, +Key, ?Value)
\end_layout

\begin_layout Standard
True if Value is the value associated with Key in Doc.
 Fails if Key is not found or does not match Value.
\end_layout

\begin_layout Subparagraph
bson:doc_put(+Doc, +Key, +Value, ?NewDoc)
\end_layout

\begin_layout Standard
True if NewDoc is Doc with the addition or update of the association Key-Value.
\end_layout

\begin_layout Subparagraph
bson:doc_delete(+Doc, +Key, ?NewDoc)
\end_layout

\begin_layout Standard
True if NewDoc is Doc with the association removed that has Key as key.
 At most one association is removed.
 No change if Key is not found.
\end_layout

\begin_layout Subparagraph
bson:doc_keys(+Doc, ?Keys)
\end_layout

\begin_layout Standard
True if Keys is the keys for the associations in Doc.
\end_layout

\begin_layout Subparagraph
bson:doc_values(+Doc, ?Values)
\end_layout

\begin_layout Standard
True if Values is the values for the associations in Doc.
\end_layout

\begin_layout Subparagraph
bson:doc_keys_values(+Doc, ?Keys, ?Values)
\end_layout

\begin_layout Standard
True if Doc is the list of successive associations of Keys and Values.
\end_layout

\begin_layout Subsubsection
Network Communication
\end_layout

\begin_layout Standard
Communication with a MongoDB instance is conducted through a Transmission
 Control Protocol (TCP) socket.
 [xxx ref mongo wire protocol]
\end_layout

\begin_layout Paragraph
Obtaining a Connection
\end_layout

\begin_layout Standard
A connection can be established by the predicate 
\noun on
mongo:new_connection
\noun default
/1,3.
 Two versions of the predicate are provided, one which assumes the default
 MongoDB host and port, and one which allows this to be specified.
 If an error occurs during the setup, an exception is thrown.
\end_layout

\begin_layout LyX-Code
?- mongo:new_connection(Connection).
\end_layout

\begin_layout LyX-Code
Connection = 
\emph on
[opaque connection handle]
\end_layout

\begin_layout Standard
The following will connect to a MongoDB instance running on localhost attached
 to the port 1234.
\end_layout

\begin_layout LyX-Code
?- mongo:new_connection(localhost, 1234, Connection).
\end_layout

\begin_layout LyX-Code
Connection = 
\emph on
[opaque connection handle]
\end_layout

\begin_layout Paragraph
Releasing a Connection
\end_layout

\begin_layout Standard
When a connection is no longer needed it must be properly released back
 to the system.
 Assuming 
\emph on
Connection
\emph default
 is a connection obtained by the predicate 
\noun on
mongo:new_connection
\noun default
/1,3, the following will release any resources associated with it, rendering
 it unusable.
\end_layout

\begin_layout LyX-Code
?- mongo:free_connection(Connection).
\end_layout

\begin_layout LyX-Code

\emph on
[Connection may no longer be used]
\end_layout

\begin_layout Subsubsection
Working with Data
\end_layout

\begin_layout Standard
This section gives an overview of the main functionality needed to work
 with databases, collections and documents.
\end_layout

\begin_layout Paragraph
Databases and Collections
\end_layout

\begin_layout Standard
A MongoDB server can contain multiple logical databases, and each database
 can contain multiple document collections.
 Once a connection to the server has been established, a handle to a logical
 database can be retrieved by the predicate 
\noun on
mongo:get_database/3
\noun default
.
 The predicate accepts a connection handle and the name of the desired database
 as an atom, and returns a handle to the database.
 The database need not exist beforehand, and will be created when it is
 first used.
\end_layout

\begin_layout Standard
The database handle can be used to execute general database commands, but
 a collection handle must be retrieved when working with documents.
 This is accomplished by the predicate 
\noun on
mongo:get_collection/3
\noun default
, which accepts a database handle and the name of the collection, and returns
 a collection handle.
 The collection need not exist beforehand, and will be created when it is
 first used.
\end_layout

\begin_layout Paragraph
Find Documents
\end_layout

\begin_layout Standard
Querying the database for documents is accomplished through the family of
 
\emph on
find
\emph default
 predicates.
 Depending on the nature of the query, different predicates can be used
 to retrieve, for example, a single document or all documents matching the
 query.
\end_layout

\begin_layout Standard
In general, a query returns documents in batches.
 A certain number of documents are returned with the query response, but
 if there are too many documents to fit in a single response, a 
\begin_inset Quotes eld
\end_inset

cursor
\begin_inset Quotes erd
\end_inset

 is established.
 The cursor can then be used to query for further documents.
\end_layout

\begin_layout Standard
The three main predicates for finding documents are 
\emph on
mongo:find/8
\emph default
, 
\emph on
mongo:find_one/4
\emph default
 and 
\emph on
mongo:find_all/4
\emph default
.
 The most general predicate is 
\emph on
find
\emph default
 which takes many arguments and offers very fine-grained control over the
 query.
 The interface to the predicate is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-find"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Collection
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collection handle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Query
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which documents to match
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+ReturnFields
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which fields to return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Skip
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of documents to skip
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Limit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of documents to return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Options
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List of option atoms
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-Cursor
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cursor used to fetch more documents
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-Docs
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Documents returned by the query
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-find"

\end_inset

Interface to mongo:find/8.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The predicate 
\emph on
find_one
\emph default
 is intended for the common case where you only expect one matching document.
 If no matching document is found, the returned document is the atom 'nil'.
 The interface is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-find-one"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Collection
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collection handle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Query
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which document to match
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+ReturnFields
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which fields to return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-Doc
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document returned by the query
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-find-one"

\end_inset

Interface to mongo:find_one/4.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The predicate 
\emph on
find_all
\emph default
 is intended for situations where all matching documents need processing
 and it is convenient to collect them into a single (potentially large)
 list.
 The interface is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-find-all"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Collection
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collection handle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Query
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which documents to match
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+ReturnFields
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which fields to return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-Docs
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Documents returned by the query
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-find-all"

\end_inset

Interface to mongo:find_all/4.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Using Cursors
\end_layout

\begin_layout Standard
When a query matches more documents than can be returned in a single response,
 a cursor is established and returned.
 A cursor is created and maintained by the database instance, and it represents
 a pointer to a subset of the documents matched by a query [xxx ref and
 maybe rewrite].
\end_layout

\begin_layout Standard
After making a query, the predicate 
\emph on
mongo:cursor_has_more/
\emph default
1 can be called on a cursor.
 The predicate succeeds if more documents can be retrieved, and its interface
 is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-cursor-has-more"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Cursor
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cursor to investigate
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-cursor-has-more"

\end_inset

Interface to mongo:cursor_has_more/1.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If more documents need to be retrieved, the predicate 
\emph on
mongo:cursor_get_more/4
\emph default
 can be used.
 This predicate takes a cursor, returns a number of documents and also a
 new cursor handle representing the possibly modified state of the cursor.
 The interface is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-cursor-get-more"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Cursor
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cursor to investigate
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Limit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of documents to return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-Docs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Documents returned by the query
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-NewCursor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
New state of Cursor
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-cursor-get-more"

\end_inset

Interface to mongo:cursor_has_more/1.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When a cursor is no longer needed, it must be explicitly killed in order
 for the database to clean up any resources claimed by it.
 This is accomplished by the predicate 
\emph on
mongo:cursor_kill/1
\emph default
, described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-cursor-kill"

\end_inset

.
 If several cursors need to be killed, a more efficient version called 
\emph on
mongo:cursor_kill_batch/1
\emph default
 can be used to kill them in a single database call.
 This predicate is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-cursor-kill-batch"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Cursor
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cursor to kill
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-cursor-kill"

\end_inset

Interface to mongo:cursor_kill/1.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Cursors
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List of cursors to kill
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-cursor-kill-batch"

\end_inset

Interface to mongo:cursor_kill_batch/1.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Should all remaining documents matched by a query need to be retrieved in
 a single step, the predicate 
\emph on
mongo:cursor_exhaust/2
\emph default
 can be used.
 This is a convenience predicate that simply queries the cursor until all
 documents have been retrieved, and returns them as a single list.
 A cursor exhausted by this predicate need not be manually killed.
 The interface is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-cursor-exhaust"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Cursor
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cursor to exhaust (and automatically kill)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-Docs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
All remaining documents pointed to by the cursor
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-cursor-exhaust"

\end_inset

Interface to mongo:cursor_exhaust/2.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Insert Documents
\end_layout

\begin_layout Standard
Two predicates are available to insert documents into a database collection.
 The simplest one is 
\emph on
mongo:insert/2
\emph default
, which accepts a collection handle and a document to insert, as described
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-insert"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Collection
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collection handle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Doc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document to insert
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-insert"

\end_inset

Interface to mongo:insert/2.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If several documents need to be inserted, a more efficient predicate called
 
\emph on
mongo:insert_batch/3
\emph default
 may be used.
 This predicate is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-insert-batch"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Collection
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collection handle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Options
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List of option atoms
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Docs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List of documents to insert
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-insert-batch"

\end_inset

Interface to mongo:insert_batch/3.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Update Documents
\end_layout

\begin_layout Standard
Updating a single document is done using the predicate 
\emph on
mongo:update/3
\emph default
.
 It accepts a collection handle, a selector document and a document describing
 the update to perform on the matched document.
 If several documents match the selector, only the first one is used.
 The interface is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-update"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Collection
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collection handle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Selector
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which document to match
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Modifier
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing the update to perform
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-update"

\end_inset

Interface to mongo:update/3.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If all matching documents need to be updated, a similar predicate called
 
\emph on
mongo:update_all/3
\emph default
 can be used.
 The interface to this predicate is identical to the one described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-update"

\end_inset

, but it performs the update on all matching documents instead of just the
 first.
\end_layout

\begin_layout Standard
A common use case is the combination of an update and an insert, sometimes
 called an 
\begin_inset Quotes eld
\end_inset

upsert
\begin_inset Quotes erd
\end_inset

.
 This predicate is called 
\emph on
mongo:upsert/3
\emph default
, and works like a normal update (described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-update"

\end_inset

) except that if the document does not exist it is inserted instead of updated
 [XXX ref].
\end_layout

\begin_layout Paragraph
Delete Documents
\end_layout

\begin_layout Standard
Deleting documents from a collection is accomplished through the predicates
 
\emph on
mongo:delete/2
\emph default
 and 
\emph on
mongo:delete/3
\emph default
.
 Both predicates accept a collection handle and a 
\begin_inset Quotes eld
\end_inset

selector
\begin_inset Quotes erd
\end_inset

 document that describes which documents to match and delete.
 All matching documents are deleted unless the option 'single_remove' is
 supplied.
 The predicate interfaces are described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-delete-2"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interface-delete-3"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Collection
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collection handle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Selector
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which documents to delete
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-delete-2"

\end_inset

Interface to mongo:delete/3.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Collection
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Collection handle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Selector
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Document describing which documents to delete
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+Options
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List of option atoms
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interface-delete-3"

\end_inset

Interface to mongo:delete/3.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
General Database Commands
\end_layout

\begin_layout Standard
Some commands deal not with documents directly, but with whole databases,
 collections or meta data.
\end_layout

\begin_layout Subsubsection
Error Handling
\end_layout

\begin_layout Standard
Errors issued by a failed query is detected by the driver and an exception
 is thrown that contains the error document returned by the database.
 The error document contains a key called 
\emph on
$err
\emph default
 that maps to an atom describing the nature of the error.
\end_layout

\begin_layout Section
Usage Example
\end_layout

\begin_layout Standard
This chapter shows an example of how to use the driver.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
[XXX Talk a lot more about how things actually are implemented.
 DCGs, sockets, wire bytes, ...]
\end_layout

\begin_layout Standard
[XXX What is this chapter supposed to contain, really? Discuss code organization
, modules? Discuss portability? Discuss efficiency (relevant?)?]
\end_layout

\begin_layout Subsection
Definite Clause Grammar
\end_layout

\begin_layout Standard
Most of the code that converts to or from lists is implemented using the
 Definite Clause Grammar (DCG) syntax in Prolog 
\begin_inset CommandInset citation
LatexCommand cite
key "prolog"

\end_inset

.
 This grammar technique provides a convenient interface to 
\begin_inset Quotes eld
\end_inset

difference lists
\begin_inset Quotes erd
\end_inset

, which is a common approach in Prolog to avoid unnecessary (and inefficient)
 list concatenation 
\begin_inset CommandInset citation
LatexCommand cite
key "okeefe"

\end_inset

.
\end_layout

\begin_layout Subsection
C Extension
\end_layout

\begin_layout Standard
A small part of the BSON handling is written in C instead of Prolog.
 This part involves conversion of integers and floats to and from bytes.
 The two reasons for this are efficiency and ease of programming.
\end_layout

\begin_layout Standard
Being able to subvert the type system in C makes it trivial to populate
 a fixed-width number with individual bytes and then interpret them as a
 whole.
 This is especially convenient when converting between bytes and floating-point
 numbers.
\end_layout

\begin_layout Standard
BSON conversion is something the driver does very often, and pushing common
 operations down to a lower-level language is likely more efficient.
\end_layout

\begin_layout Subsection
Test Suite
\end_layout

\begin_layout Standard
Unit testing is conducted using 
\emph on
PlUnit,
\emph default
 a unit testing framework built into SWI-Prolog and designed to be compatible
 with other Prolog implementations [XXX ref].
\end_layout

\begin_layout Subsection
Environment
\end_layout

\begin_layout Standard
The technical environment used during development is as follows.
\end_layout

\begin_layout Description
POSIX The driver is developed on a POSIX (Portable Operating System Interface
 for Unix) compliant system.
\end_layout

\begin_layout Description
Prolog The driver is developed and tested on SWI-Prolog 5.10.2.
\end_layout

\begin_layout Description
C
\begin_inset space ~
\end_inset

Compiler An ANSI C compiler is required to build parts of the low-level
 BSON handling.
\end_layout

\begin_layout Description
MongoDB The driver is tested on MongoDB versions 1.8.0 and 1.8.1.
\end_layout

\begin_layout Section
Evaluation
\end_layout

\begin_layout Standard

\emph on
[xxx Did it work? Is it usable? What should have been done differently?]
\end_layout

\begin_layout Section
Conclusion/Future Work [XXX merge or split?]
\end_layout

\begin_layout Standard

\emph on
[xxx Not sure how much this section relates to Evaluation above.
\end_layout

\begin_layout Standard

\emph on
Portability (Tested on Mac, SWI, GCC/Clang, etc.)? Efficiency? How to improve
 in the future? Write a C extension with more/most functionality? Incorporate
 BSON C implementation? Don't know how portable that would be though, but
 SWI (and probably SICStus?) has a mature interface to C.
 What is missing for it to be a 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 driver? Discuss choice of list as BSON document.
 Maybe use some map-like structure instead.]
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "mongo"

\end_inset

Chodorow, K.
 & Dirolf, M.
 (2010) 
\emph on
MongoDB: The Definitive Guide.

\emph default
 Sebastopol, United States of America: O'Reilly Media, Inc.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "prolog"

\end_inset

Clocksin, W.
 F.
 & Mellish, C.
 S.
 (1994) 
\emph on
Programming in Prolog.

\emph default
 4th ed.
 New York, United States of America: Springer-Verlag.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "bratko"

\end_inset

Bratko, I.
 (2001) 
\emph on
PROLOG Programming for Artificial Intelligence.

\emph default
 3rd ed.
 Essex, England: Pearson Education Limited.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "okeefe"

\end_inset

O'Keefe, R.
 A.
 (1990) 
\emph on
The Craft of Prolog.

\emph default
 Cambridge, United States of America: The MIT Press.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "guidelines"

\end_inset

Some Coding Guidelines for Prolog
\begin_inset Newline newline
\end_inset

Covington, M.
 A.
 et al.
 Retrieved 2011-06-07.
 [xxx how to format web refs? article?]
\begin_inset Newline newline
\end_inset


\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.ai.uga.edu/mc/plcoding.pdf
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "driver_req"

\end_inset

Mongo Driver Requirements
\begin_inset Newline newline
\end_inset


\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.mongodb.org/display/DOCS/Mongo+Driver+Requirements
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "bson"

\end_inset

BSON Specification, Retrieved 2011-06-07.
\begin_inset Newline newline
\end_inset


\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://bsonspec.org/
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "json"

\end_inset

JSON Specification, Retrieved 2011-06-19.
\begin_inset Newline newline
\end_inset


\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.json.org/
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "swi"

\end_inset

SWI-Prolog Documentation
\begin_inset Newline newline
\end_inset


\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.swi-prolog.org/
\end_layout

\end_inset


\end_layout

\end_body
\end_document
